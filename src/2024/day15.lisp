(defpackage :aoc/2024/15 #.cl-user::*aoc-use*)
(in-package :aoc/2024/15)

#;
(sb-ext:gc :full t)

(defun move-straight (dir pos) (mapcar #'+ pos dir))
(defun rotate-cw (dir) (list (second dir) (- (first dir))))
#+#:excluded (defun rotate-ccw (dir) (list (- (second dir)) (first dir)))

(defun parse-input (&optional (strings (uiop:read-file-lines #P"src/2024/day15.txt")))
  (destructuring-bind (map movements) (split-sequence:split-sequence "" strings :test 'string=)
    (flet ((parse-map (strings)
             (let  ((map (make-hash-table :test 'equal))
                    (robot nil))
               (doseq ((i s) (enumerate strings))
                 (doseq ((j ch) (enumerate s))
                   (setf (gethash (list i j) map) ch)
                   (if (char= ch #\@) (setf robot (list i j)))))
               (list map robot)))
           (parse-movements (strings)
             (looping
               (dolist (s strings)
                 (doseq (ch s)
                   (collect! (ecase ch
                               (#\^ (list -1 0))
                               (#\> (list 0 1))
                               (#\v (list 1 0))
                               (#\< (list 0 -1)))))))))
      (list (parse-map map) (parse-movements movements)))))
#+#:excluded (parse-input)

(defun move-all (&optional (input (parse-input)))
  (destructuring-bind ((map (ri rj)) movements) input
    (doseq ((di dj) movements)
      (labels ((move (i j &aux (pos (list i j)))
                 (let1 pos1 (list (+ i di) (+ j dj))
                   #+#:excluded (dbgl pos1 (gethash pos1 map))
                   (cond ((char= (gethash pos1 map) #\.) (rotatef (gethash pos1 map)
                                                                  (gethash pos map))
                                                         t)
                         ((char= (gethash pos1 map) #\O) (when (move (+ i di) (+ j dj))
                                                           (rotatef (gethash pos1 map)
                                                                    (gethash pos map))
                                                           t))
                         (t (assert (char= (gethash pos1 map) #\#)))))))
        #+#:excluded (dbgl ri rj di dj)
        (if (move ri rj)
            (setf ri (+ ri di) rj (+ rj dj)))))
    (result map)))
(move-all (parse-input))

(defun result (map)
  (looping
    (dohash ((i j) ch map)
      (when (char= ch #\O)
        (sum! (+ (* i 100) j))))))

(defun parse-input (&optional (strings (uiop:read-file-lines #P"src/2024/day15.txt")))
  (destructuring-bind (map movements) (split-sequence:split-sequence "" strings :test 'string=)
    (flet ((parse-map (strings)
             (let  ((map (make-hash-table :test 'equal))
                    (robot nil))
               (doseq ((i s) (enumerate strings))
                 (doseq ((j ch) (enumerate s))
                   (ecase ch
                     (#\# (setf (gethash (list i (* j 2)) map) ch
                                (gethash (list i (1+ (* j 2))) map) ch))
                     (#\. (setf (gethash (list i (* j 2)) map) ch
                                (gethash (list i (1+ (* j 2))) map) ch))
                     (#\O (setf (gethash (list i (* j 2)) map) #\[
                                (gethash (list i (1+ (* j 2))) map) #\]))
                     (#\@ (setf (gethash (list i (* j 2)) map) #\@
                                (gethash (list i (1+ (* j 2))) map) #\.)))
                   (if (char= ch #\@) (setf robot (list i (* j 2))))))
               (list map robot)))
           (parse-movements (strings)
             (looping
               (dolist (s strings)
                 (doseq (ch s)
                   (collect! (ecase ch
                               (#\^ (list -1 0))
                               (#\> (list 0 1))
                               (#\v (list 1 0))
                               (#\< (list 0 -1)))))))))
      (list (parse-map map) (parse-movements movements)))))
#+#:excluded (parse-input)

(defun move-all (&optional (input (parse-input)))
  (destructuring-bind ((map (ri rj)) movements) input
    (doseq ((di dj) movements)
      (labels ((moving-vertically? () (/= di 0))
               (moving-left? () (< dj 0))
               (moving-right? () (> dj 0))
               (straight-from (pos) (list (+ (car pos) di) (+ (cadr pos) dj)))
               (right-of (pos) (list (car pos) (1+ (cadr pos))))
               (left-of (pos) (list (car pos) (1- (cadr pos))))
               (swap (pos1 pos2) (rotatef (gethash pos1 map) (gethash pos2 map)) t)
               (can-move? (pos)
                 (cond ((char= (gethash pos map) #\.) t)
                       ((char= (gethash pos map) #\#) nil)
                       ((char= (gethash pos map) #\@) (can-move? (straight-from pos)))
                       ((char= (gethash pos map) #\[)
                        (cond ((moving-vertically?) (and (can-move? (straight-from pos))
                                                         (can-move? (right-of (straight-from pos)))))
                              (t (can-move? (straight-from pos)))))
                       ((char= (gethash pos map) #\])
                        (cond ((moving-vertically?) (and (can-move? (straight-from pos))
                                                         (can-move? (left-of (straight-from pos)))))
                              (t (can-move? (straight-from pos)))))
                       (t (error "Cannot be here"))))
               (move (pos)
                 (cond ((char= (gethash pos map) #\.) #+#:excluded (error "NEVER ."))
                       ((char= (gethash pos map) #\#) (error "NEVER #"))
                       ((char= (gethash pos map) #\@) (move (straight-from pos))
                                                      (swap pos (straight-from pos)))
                       ((char= (gethash pos map) #\[)
                        (cond ((moving-vertically?) (move (straight-from pos))
                                                    (move (right-of (straight-from pos)))
                                                    (swap pos (straight-from pos))
                                                    (swap (right-of pos) (straight-from (right-of pos))))
                              (t (move (straight-from pos))
                                 (swap pos (straight-from pos)))))
                       ((char= (gethash pos map) #\])
                        (cond ((moving-vertically?) (move (straight-from pos))
                                                    (move (left-of (straight-from pos)))
                                                    (swap pos (straight-from pos))
                                                    (swap (left-of pos) (straight-from (left-of pos))))
                              (t (move (straight-from pos))
                                 (swap pos (straight-from pos)))))
                       (t (error "Cannot be here")))))
        ; (dbgl ri rj di dj)
        (assert (char= (gethash (list ri rj) map) #\@))
        ; (display map)
        ; (break)
        (when (can-move? (list ri rj))
          (move (list ri rj))
          (setf ri (+ ri di) rj (+ rj dj)))))
    #+#:excluded (display map)
    (dbg (result map))
    #+#:excluded (display map)))
(move-all (parse-input))

(defun display (map &aux (h 10) (w (* h 2)))
  (dotimes (i h)
    (dotimes (j w)
      (pr (gethash (list i j) map)))
    (pr #\Newline)))

(defun result (map &aux (h 50) (w (* h 2)))
  (looping
    (dotimes (i h)
      (dotimes (j w)
        (when (char= (gethash (list i j) map) #\[)
          (let1 di (min i #+#:excluded (- h i 1))
            (let1 dj (min j #+#:excluded (- w j 2))
              #+#:excluded (dbgl i j h w di dj)
              ; (break)
              (sum! (+ (* 100 di) dj)))))))))

; 19125000 too high
; 18872500 too high

(define-solution (2024 15) (input parse-input)
  (values (looping
            (doseq ((a b prize) input)
              (awhen (solve a b prize)
                (sum! it))))
          (looping
            (doseq ((a b (px py)) input)
              (awhen (solve a b (list (+ px 10000000000000) (+ py 10000000000000)))
                (sum! it))))))

(define-test (2024 15) (39290 73458657399094))
