;;;; This file was automatically generated by Quickutil.
;;;; See http://quickutil.org for details.

;;;; To regenerate:
;;;; (qtlc:save-utils-as "quickutils.lisp" :utilities '(:KEEP-IF :KEEP-IF-NOT :AAND :AIF :ALIST-KEYS :ALIST-VALUES :APPENDF :ASSOC-VALUE :AWHEN :BND* :BND1 :COPY-ARRAY :COPY-HASH-TABLE :DEFACCESSOR :DIGITS :DIVF :DOALIST :DOHASH :DOLISTS :DORANGE :DORANGEI :DOSEQ :DOSEQS :DOSUBLISTS :ENUMERATE :FLATTEN :HASH-TABLE-ALIST :HASH-TABLE-KEY-EXISTS-P :HASH-TABLE-KEYS :HASH-TABLE-VALUES :IF-LET :IF-NOT :IOTA :LAST-ELT :LOOPING :MAKE-KEYWORD :MKSTR :MULF :NCYCLE :PLIST-KEYS :PLIST-VALUES :RANDOM-ELT :RECURSIVELY :REMOVEF :REPEAT :SHUFFLE :STRING-ENDS-WITH-P :STRING-STARTS-WITH-P :SUBDIVIDE :SUBSEQ- :SYMB :VOID :WHEN-LET :WHEN-NOT :WHILE :WHILE-NOT :WITH-GENSYMS :XOR) :ensure-package T :package "AOC.QUICKUTILS")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package "AOC.QUICKUTILS")
    (defpackage "AOC.QUICKUTILS"
      (:documentation "Package that contains Quickutil utility functions.")
      (:use #:cl))))

(in-package "AOC.QUICKUTILS")

(when (boundp '*utilities*)
  (setf *utilities* (union *utilities* '(:ABBR :KEEP-IF :KEEP-IF-NOT :LET1 :AIF
                                         :AAND :ALIST-KEYS :ALIST-VALUES
                                         :APPENDF :STRING-DESIGNATOR
                                         :WITH-GENSYMS :ASSOC-VALUE :AWHEN
                                         :BND* :BND1 :COPY-ARRAY
                                         :COPY-HASH-TABLE :PARSE-BODY
                                         :DEFACCESSOR :DIGITS :DIVF
                                         :MAKE-GENSYM-LIST :ONCE-ONLY :DOALIST
                                         :DOHASH :DOLISTS :DORANGE :DORANGEI
                                         :DOSEQ :DOSEQS :DOSUBLISTS :ENUMERATE
                                         :FLATTEN :HASH-TABLE-ALIST
                                         :HASH-TABLE-KEY-EXISTS-P :MAPHASH-KEYS
                                         :HASH-TABLE-KEYS :MAPHASH-VALUES
                                         :HASH-TABLE-VALUES :IF-LET :IF-NOT
                                         :IOTA :NON-ZERO-P :EMPTYP :SAFE-ENDP
                                         :CIRCULAR-LIST
                                         :PROPER-LIST-LENGTH/LAST-CAR
                                         :PROPER-LIST-P :PROPER-LIST
                                         :PROPER-SEQUENCE :LAST-ELT :LOOPING
                                         :MAKE-KEYWORD :MKSTR :MULF :NCYCLE
                                         :PLIST-KEYS :PLIST-VALUES :RANDOM-ELT
                                         :RECURSIVELY :REMOVEF :REPEAT :SHUFFLE
                                         :STRING-ENDS-WITH-P
                                         :STRING-STARTS-WITH-P :SUBDIVIDE
                                         :SUBSEQ- :SYMB :VOID :WHEN-LET
                                         :WHEN-NOT :WHILE :UNTIL :WHILE-NOT
                                         :XOR))))

  (defmacro abbr (short long)
    "Defines a new function/macro named `short` and sharing
FDEFINITION/MACRO-FUNCTION with `long`."
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       (cond
         ((macro-function ',long)
          (setf (macro-function ',short) (macro-function ',long))
          #+ccl (setf (ccl:arglist ',short) (ccl:arglist ',long)))
         ((fboundp ',long)
          (setf (fdefinition ',short) (fdefinition ',long))
          #+ccl (setf (ccl:arglist ',short) (ccl:arglist ',long)))
         (t
           (error "Can't abbreviate ~a" ',long)))))
  
  (abbr keep-if remove-if-not)
  (abbr keep-if-not remove-if)

  (defmacro let1 (var val &body body)
    "Bind VAR to VAL within BODY. Equivalent to LET with one binding."
    `(let ((,var ,val))
       ,@body))
  

  (defmacro aif (test then &optional else)
    "Like IF, except binds the result of `test` to IT (via LET) for the scope of `then` and `else` expressions."
    (aif-expand test then else))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun aif-expand (test then &optional else)
      (let1 it (intern "IT")
        `(let1 ,it ,test
           (if ,it ,then ,else)))))
  

  (defmacro aand (&rest forms)
    "Like AND, except binds the result of each form to IT (via LET)."
    (aand-expand forms))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun aand-expand (forms)
      (cond ((not (car forms)) nil)
            ((not (cdr forms)) (car forms))
            (t (let1 car (car forms)
                 `(aif ,car
                    (aand ,@(cdr forms))))))))
  

  (defun alist-keys (alist)
    "Return all the keys of `alist`."
    (mapcar #'car alist))
  

  (defun alist-values (alist)
    "Return all the values of `alist`."
    (mapcar #'cdr alist))
  

  (define-modify-macro appendf (&rest lists) append
    "Modify-macro for `append`. Appends `lists` to the place designated by the first
argument.")
  

  (deftype string-designator ()
    "A string designator type. A string designator is either a string, a symbol,
or a character."
    `(or symbol string character))
  

  (defmacro with-gensyms (names &body forms)
    "Binds each variable named by a symbol in `names` to a unique symbol around
`forms`. Each of `names` must either be either a symbol, or of the form:

    (symbol string-designator)

Bare symbols appearing in `names` are equivalent to:

    (symbol symbol)

The string-designator is used as the argument to `gensym` when constructing the
unique symbol the named variable will be bound to."
    `(let ,(mapcar (lambda (name)
                     (multiple-value-bind (symbol string)
                         (etypecase name
                           (symbol
                            (values name (symbol-name name)))
                           ((cons symbol (cons string-designator null))
                            (values (first name) (string (second name)))))
                       `(,symbol (gensym ,string))))
            names)
       ,@forms))

  (defmacro with-unique-names (names &body forms)
    "Binds each variable named by a symbol in `names` to a unique symbol around
`forms`. Each of `names` must either be either a symbol, or of the form:

    (symbol string-designator)

Bare symbols appearing in `names` are equivalent to:

    (symbol symbol)

The string-designator is used as the argument to `gensym` when constructing the
unique symbol the named variable will be bound to."
    `(with-gensyms ,names ,@forms))
  

  (declaim (inline racons))
  (defun racons (key value ralist)
    (acons value key ralist))
  
  (macrolet
      ((define-alist-get (name get-entry get-value-from-entry add doc)
         `(progn
            (declaim (inline ,name))
            (defun ,name (alist key &key (test 'equal))
              ,doc
              (let ((entry (,get-entry key alist :test test)))
                (values (,get-value-from-entry entry) entry)))
            (define-setf-expander ,name (place key &key (test ''equal)
                                                   &environment env)
              (multiple-value-bind
                    (temporary-variables initforms newvals setter getter)
                  (get-setf-expansion place env)
                (when (cdr newvals)
                  (error "~A cannot store multiple values in one place" ',name))
                (with-unique-names (new-value key-val test-val alist entry)
                  (values
                   (append temporary-variables
                           (list alist
                                 key-val
                                 test-val
                                 entry))
                   (append initforms
                           (list getter
                                 key
                                 test
                                 `(,',get-entry ,key-val ,alist :test ,test-val)))
                   `(,new-value)
                   `(cond
                      (,entry
                       (setf (,',get-value-from-entry ,entry) ,new-value))
                      (t
                       (let ,newvals
                         (setf ,(first newvals) (,',add ,key ,new-value ,alist))
                         ,setter
                         ,new-value)))
                   `(,',get-value-from-entry ,entry))))))))
    
    (define-alist-get assoc-value assoc cdr acons
      "ASSOC-VALUE is an alist accessor very much like ASSOC, but it can
be used with SETF.")
    
    (define-alist-get rassoc-value rassoc car racons
      "RASSOC-VALUE is an alist accessor very much like RASSOC, but it can
be used with SETF."))
  

  (defmacro awhen (test &body body)
    "Like WHEN, except binds the result of `test` to IT (via LET) for the scope of `body`."
    (awhen-expand test body))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun awhen-expand (test body)
      (let1 it (intern "IT")
        `(let1 ,it ,test
           (when ,it
             ,@body)))))
  

  (defmacro bnd* (bindings &body body)
    "Like LET*, but more powerful.

Use a symbol as the name of the binding to expand to a standard LET:

(bnd* (x
       (y (list 1 2 3)))
  (list x y)) ≡
(let (x)
  (let ((y (list 1 2 3)))
    (list x y)))

Use a list as the name of the binding to enable special type of expansions.

If the CAR of the list is the symbol VALUES, expand to MULTIPLE-VALUE-BIND
call:

(bnd* (((values f r) (floor 130 11)))
  (list f r)) ≡
(multiple-value-bind (f r)
     (floor 130 11)
   (list f r))

If the CAR of the list is the symbol WITH-SLOTS, expand to a WITH-SLOTS call:

(bnd* (((with-slots x y) thing))
  (incf x) (incf y))
≡
(with-slots (x y) thing
  (incf x) (incf y))

Otherwise, if the name of the binding is a list but none of the above applies,
BND* will expand to a DESTRUCTURING-BIND call:

(bnd* (((a b) '(1 2)))
  (list a b))
≡
(destructuring-bind (a b)
    '(1 2)
  (list a b))"
    (labels ((mklist (x) (if (atom x) (list x) x))
             (expand (bb)
               (cond ((null bb) (signal 'unexpected))
                     (t (let* ((b (mklist (car bb)))
                               (var (car b))
                               (val (cadr b)))
                          (cond ((symbolp var)
                                 `(let (,b)
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                ((eq (car var) 'values)
                                 `(multiple-value-bind ,(rest var) ,val
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                ((eq (car var) 'with-slots)
                                 `(with-slots ,(rest var) ,val
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                (t `(destructuring-bind ,@b
                                      ,@(if (rest bb)
                                          (list (expand (rest bb)))
                                          body)))))))))
      (expand bindings)))
  

  (defmacro bnd1 (var val &body body)
    "BND1 is to BND* like LET1 is to LET*."
    `(bnd* ((,var ,val))
       ,@body))
  

  (defun copy-array (array &key (element-type (array-element-type array))
                                (fill-pointer (and (array-has-fill-pointer-p array)
                                                   (fill-pointer array)))
                                (adjustable (adjustable-array-p array)))
    "Returns an undisplaced copy of `array`, with same `fill-pointer` and
adjustability (if any) as the original, unless overridden by the keyword
arguments."
    (let* ((dimensions (array-dimensions array))
           (new-array (make-array dimensions
                                  :element-type element-type
                                  :adjustable adjustable
                                  :fill-pointer fill-pointer)))
      (dotimes (i (array-total-size array))
        (setf (row-major-aref new-array i)
              (row-major-aref array i)))
      new-array))
  

  (defun copy-hash-table (table &key key test size
                                     rehash-size rehash-threshold)
    "Returns a copy of hash table `table`, with the same keys and values
as the `table`. The copy has the same properties as the original, unless
overridden by the keyword arguments.

Before each of the original values is set into the new hash-table, `key`
is invoked on the value. As `key` defaults to `cl:identity`, a shallow
copy is returned by default."
    (setf key (or key 'identity))
    (setf test (or test (hash-table-test table)))
    (setf size (or size (hash-table-size table)))
    (setf rehash-size (or rehash-size (hash-table-rehash-size table)))
    (setf rehash-threshold (or rehash-threshold (hash-table-rehash-threshold table)))
    (let ((copy (make-hash-table :test test :size size
                                 :rehash-size rehash-size
                                 :rehash-threshold rehash-threshold)))
      (maphash (lambda (k v)
                 (setf (gethash k copy) (funcall key v)))
               table)
      copy))
  

  (defun parse-body (body &key documentation whole)
    "Parses `body` into `(values remaining-forms declarations doc-string)`.
Documentation strings are recognized only if `documentation` is true.
Syntax errors in body are signalled and `whole` is used in the signal
arguments when given."
    (let ((doc nil)
          (decls nil)
          (current nil))
      (tagbody
       :declarations
         (setf current (car body))
         (when (and documentation (stringp current) (cdr body))
           (if doc
               (error "Too many documentation strings in ~S." (or whole body))
               (setf doc (pop body)))
           (go :declarations))
         (when (and (listp current) (eql (first current) 'declare))
           (push (pop body) decls)
           (go :declarations)))
      (values body (nreverse decls) doc)))
  

  (defmacro defaccessor (name lambda-list &body body)
    "Define the function named `name` just as with a normal `defun`. Also define the setter `(setf name)`. The form to be set (i.e., the place) should be wrapped in the local macro `accesses`. For example,

```
  CL-USER> (let ((x 0))
             (defaccessor saved-x ()
               (accesses x)))
  SAVED-X
  (SETF SAVED-X)
  CL-USER> (saved-x)
  0
  CL-USER> (setf (saved-x) 5)
  5
  CL-USER> (saved-x)
  5
```
"
    (multiple-value-bind (remaining-forms decls doc)
        (parse-body body :documentation t)
      (with-gensyms (new-value)
        `(progn
           (defun ,name ,lambda-list
             ,doc
             ,@decls
             (macrolet ((accesses (form)
                          form))
               ,@remaining-forms))
         
           (defun (setf ,name) ,(cons new-value lambda-list)
             ,(format nil "Setter for the function ~S." name)
             ,@decls
             (macrolet ((accesses (form)
                          `(setf ,form ,',new-value)))
               ,@remaining-forms
               ,new-value))
           (values
            ',name
            '(setf ,name))))))
  

  (defun digits (n &optional (base 10))
    "Return a list of the digits of the non-negative integer `n` in base
`base`. By default, decimal digits are returned.

The order of the digits is such that the `k`th element of the list refers to the coefficient of `base^k`. In other words, given the resulting list

    (c0 c1 c2 ... ck)

the following identity holds:

    n = c0 + c1*base + c2*base^2 + ... + ck*base^k."
    (check-type n (integer 0))
    (check-type base (integer 2))
    (loop :with remainder
          :do (setf (values n remainder) (truncate n base))
          :collect remainder
          :until (zerop n)))
  

  (define-modify-macro divf (&optional (1/ratio 2)) /
    "A modifying version of division, similar to `decf`.")
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun make-gensym-list (length &optional (x "G"))
    "Returns a list of `length` gensyms, each generated as if with a call to `make-gensym`,
using the second (optional, defaulting to `\"G\"`) argument."
    (let ((g (if (typep x '(integer 0)) x (string x))))
      (loop repeat length
            collect (gensym g))))
  )                                        ; eval-when

  (defmacro once-only (specs &body forms)
    "Evaluates `forms` with symbols specified in `specs` rebound to temporary
variables, ensuring that each initform is evaluated only once.

Each of `specs` must either be a symbol naming the variable to be rebound, or of
the form:

    (symbol initform)

Bare symbols in `specs` are equivalent to

    (symbol symbol)

Example:

    (defmacro cons1 (x) (once-only (x) `(cons ,x ,x)))
      (let ((y 0)) (cons1 (incf y))) => (1 . 1)"
    (let ((gensyms (make-gensym-list (length specs) "ONCE-ONLY"))
          (names-and-forms (mapcar (lambda (spec)
                                     (etypecase spec
                                       (list
                                        (destructuring-bind (name form) spec
                                          (cons name form)))
                                       (symbol
                                        (cons spec spec))))
                                   specs)))
      ;; bind in user-macro
      `(let ,(mapcar (lambda (g n) (list g `(gensym ,(string (car n)))))
              gensyms names-and-forms)
         ;; bind in final expansion
         `(let (,,@(mapcar (lambda (g n)
                             ``(,,g ,,(cdr n)))
                           gensyms names-and-forms))
            ;; bind in user-macro
            ,(let ,(mapcar (lambda (n g) (list (car n) g))
                    names-and-forms gensyms)
               ,@forms)))))
  

  (defmacro doalist ((key val alist &optional (result nil result?)) &body body)
    "Iterates over the elements of `alist`."
    (once-only (alist)
      `(loop :for (,key . ,val) :in ,alist :do ,@body ,@(when result? `(:finally (return ,result))))))
  

  (defmacro dohash ((key value table &optional (result nil result?)) &body body)
    "Iterate over the hash table `table`, executing `body`, with `key` and
   `value` bound to the keys and values of the hash table
   respectively. Return `result` from the iteration form."
    `(loop :for ,key :being :the :hash-keys :of ,table :using (hash-value ,value) :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defmacro dolists (((var1 list1) (var2 list2) &rest var-list-specs) &body body)
    "Like DOLIST, except it allows you to iterate over multiple lists in parallel.

  > (let ((list '(1 2 3 4)))
      (dolists ((x1 list)
                (x2 (cdr list)))
        (print (list x1 x2))))
  ;; (1 2)
  ;; (2 3)
  ;; (3 4)
  NIL
  "
    `(loop
       :for ,var1 :in ,list1 :for ,var2 :in ,list2
       ,@(loop for (var list) in var-list-specs
               collect 'FOR collect var collect 'IN collect list)
       :do ,@body))
  

  (defmacro dorange ((var from to &optional (step 1) (result nil result?)) &body body)
    "Binds `var` to all the distinct values in the range [`from`, `to`[, with
`step` step (note: `to` is excluded), and runs `body` inside that
lexical environmnet."
    (let ((step-g (gensym "step"))
          (to-g (gensym "to")))
      `(do* ((,step-g ,step)
             (,to-g ,to)
             (,var ,from (+ ,var ,step-g)))
         ((if (>= ,step-g 0) (>= ,var ,to-g) (<= ,var ,to-g))
          ,@(when result? `(,result)))
         ,@body)))
  

  (defmacro dorangei ((var from to &optional (step 1) (result nil result?)) &body body)
    "Like DORANGE, `to` is inclusive (the range is: [`from`, `to`])."
    (let ((step-g (gensym "step"))
          (to-g (gensym "to")))
      `(do* ((,step-g ,step)
             (,to-g ,to)
             (,var ,from (+ ,var ,step-g)))
         ((if (>= ,step-g 0) (> ,var ,to-g) (< ,var ,to-g))
          ,@(when result? `(,result)))
         ,@body)))
  

  (defmacro doseq ((var seq &optional (result nil result?)) &body body)
    "Iterate across the sequence `seq`, binding the variable `var` to
each element of the sequence and executing `body`. Return the value
`return` from the iteration form.

Note: DOSEQ expands to a LOOP form, so `var` can either be a symbol, or a
lambda-list
"
    (once-only (seq)
      `(etypecase ,seq
         (list (loop :for ,var :in ,seq :do ,@body ,@(when result? `(:finally (return ,result)))))
         (sequence (loop :for ,var :across ,seq :do ,@body ,@(when result? `(:finally (return ,result))))))))
  

  (defmacro doseqs (((var1 seq1) (var2 seq2) &rest var-seq-specs) &body body)
    "Like DOSEQ, except this can iterate over multiple sequences at the same
time."
    (let* ((vars (list* var1 var2 (mapcar #'car var-seq-specs)))
           (seqs (list* seq1 seq2 (mapcar #'cadr var-seq-specs))))

      `(block nil
         (map nil (lambda (,@vars) ,@body) ,@seqs))))
  

  (defmacro dosublists ((var list &optional (result nil result?)) &body body)
    "Like DOLIST, except:

- `var` is bound to successive sublists of `list` (similar to MAPL, LOOP..ON)
- `var` can be a lambda-list
"
    `(loop :for ,var :on ,list :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defgeneric enumerate (x &key start)
    (:documentation "Equivalent to `(zip (iota (length x)) x)`."))

  (defmethod enumerate ((x list) &key (start 0))
    "Equivalent to `(zip (iota (length x)) x)`."
    (loop
      :for i :in x
      :for j :from start
      :collect (list j i)))

  (defmethod enumerate ((x array) &key (start 0))
    "Equivalent to `(zip (iota (length x)) x)`."
    (loop
      :for i :across x
      :for j :from start
      :collect (list j i)))
  

  (defun flatten (&rest xs)
    "Flatten (and append) all lists `xs` completely."
    (labels ((rec (xs acc)
               (cond ((null xs)  acc)
                     ((consp xs) (rec (car xs) (rec (cdr xs) acc)))
                     (t          (cons xs acc)))))
      (rec xs nil)))
  

  (defun hash-table-alist (table)
    "Returns an association list containing the keys and values of hash table
`table`."
    (let ((alist nil))
      (maphash (lambda (k v)
                 (push (cons k v) alist))
               table)
      alist))
  

  (defun hash-table-key-exists-p (hash-table key)
    "Does `key` exist in `hash-table`?"
    (nth-value 1 (gethash key hash-table)))
  

  (declaim (inline maphash-keys))
  (defun maphash-keys (function table)
    "Like `maphash`, but calls `function` with each key in the hash table `table`."
    (maphash (lambda (k v)
               (declare (ignore v))
               (funcall function k))
             table))
  

  (defun hash-table-keys (table)
    "Returns a list containing the keys of hash table `table`."
    (let ((keys nil))
      (maphash-keys (lambda (k)
                      (push k keys))
                    table)
      keys))
  

  (declaim (inline maphash-values))
  (defun maphash-values (function table)
    "Like `maphash`, but calls `function` with each value in the hash table `table`."
    (maphash (lambda (k v)
               (declare (ignore k))
               (funcall function v))
             table))
  

  (defun hash-table-values (table)
    "Returns a list containing the values of hash table `table`."
    (let ((values nil))
      (maphash-values (lambda (v)
                        (push v values))
                      table)
      values))
  

  (defmacro if-let (bindings &body (then-form &optional else-form))
    "Creates new variable bindings, and conditionally executes either
`then-form` or `else-form`. `else-form` defaults to `nil`.

`bindings` must be either single binding of the form:

    (variable initial-form)

or a list of bindings of the form:

    ((variable-1 initial-form-1)
     (variable-2 initial-form-2)
     ...
     (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, the `then-form` is executed with the
bindings in effect, otherwise the `else-form` is executed with the bindings in
effect."
    (let* ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                             (list bindings)
                             bindings))
           (variables (mapcar #'car binding-list)))
      `(let ,binding-list
         (if (and ,@variables)
             ,then-form
             ,else-form))))
  

  (defmacro if-not (test then &optional else)
    "Like IF, except TEST gets wrapped inside NOT."
    `(if (not ,test) ,then ,else))
  

  (declaim (inline iota))
  (defun iota (n &key (start 0) (step 1))
    "Return a list of `n` numbers, starting from `start` (with numeric contagion
from `step` applied), each consequtive number being the sum of the previous one
and `step`. `start` defaults to `0` and `step` to `1`.

Examples:

    (iota 4)                      => (0 1 2 3)
    (iota 3 :start 1 :step 1.0)   => (1.0 2.0 3.0)
    (iota 3 :start -1 :step -1/2) => (-1 -3/2 -2)"
    (declare (type (integer 0) n) (number start step))
    (loop repeat n
          ;; KLUDGE: get numeric contagion right for the first element too
          for i = (+ (- (+ start step) step)) then (+ i step)
          collect i))
  

  (defun non-zero-p (n)
    "Check if `n` is non-zero."
    (not (zerop n)))
  

  (defgeneric emptyp (object)
    (:documentation "Determine if `object` is empty.")
    (:method ((x null)) t)
    (:method ((x cons)) nil)
    (:method ((x vector)) (zerop (length x))) ; STRING :< VECTOR
    (:method ((x array)) (notany #'non-zero-p (array-dimensions x)))
    (:method ((x hash-table)) (zerop (hash-table-count x))))
  

  (declaim (inline safe-endp))
  (defun safe-endp (x)
    (declare (optimize safety))
    (endp x))
  

  (defun circular-list (&rest elements)
    "Creates a circular list of ELEMENTS."
    (let ((cycle (copy-list elements)))
      (nconc cycle cycle)))

  (defun circular-list-p (object)
    "Returns true if OBJECT is a circular list, NIL otherwise."
    (and (listp object)
         (do ((fast object (cddr fast))
              (slow (cons (car object) (cdr object)) (cdr slow)))
             (nil)
           (unless (and (consp fast) (listp (cdr fast)))
             (return nil))
           (when (eq fast slow)
             (return t)))))
  
  (defun make-circular-list (length &key initial-element)
    "Creates a circular list of LENGTH with the given INITIAL-ELEMENT."
    (let ((cycle (make-list length :initial-element initial-element)))
      (nconc cycle cycle)))

  (deftype circular-list ()
    "Type designator for circular lists. Implemented as a SATISFIES type, so not
recommended for performance intensive use. Main usefullness as the
expected-type designator of a TYPE-ERROR."
    `(satisfies circular-list-p))
  

  (defun circular-list-error (list)
    (error 'type-error
           :datum list
           :expected-type '(and list (not circular-list))))
  
  (macrolet ((def (name lambda-list doc step declare ret1 ret2)
               (assert (member 'list lambda-list))
               `(defun ,name ,lambda-list
                  ,doc
                  (do ((last list fast)
                       (fast list (cddr fast))
                       (slow (cons (car list) (cdr list)) (cdr slow))
                       ,@(when step (list step)))
                      (nil)
                    (declare (dynamic-extent slow) ,@(when declare (list declare))
                             (ignorable last))
                    (when (safe-endp fast)
                      (return ,ret1))
                    (when (safe-endp (cdr fast))
                      (return ,ret2))
                    (when (eq fast slow)
                      (circular-list-error list))))))
    (def proper-list-length (list)
      "Returns length of LIST, signalling an error if it is not a proper list."
      (n 1 (+ n 2))
      ;; KLUDGE: Most implementations don't actually support lists with bignum
      ;; elements -- and this is WAY faster on most implementations then declaring
      ;; N to be an UNSIGNED-BYTE.
      (fixnum n)
      (1- n)
      n)

    (def lastcar (list)
      "Returns the last element of LIST. Signals a type-error if LIST is not a
proper list."
      nil
      nil
      (cadr last)
      (car fast))

    (def (setf lastcar) (object list)
      "Sets the last element of LIST. Signals a type-error if LIST is not a proper
list."
      nil
      nil
      (setf (cadr last) object)
      (setf (car fast) object)))
  

  (defun proper-list-p (object)
    "Returns true if `object` is a proper list."
    (cond ((not object)
           t)
          ((consp object)
           (do ((fast object (cddr fast))
                (slow (cons (car object) (cdr object)) (cdr slow)))
               (nil)
             (unless (and (listp fast) (consp (cdr fast)))
               (return (and (listp fast) (not (cdr fast)))))
             (when (eq fast slow)
               (return nil))))
          (t
           nil)))
  

  (deftype proper-list ()
    "Type designator for proper lists. Implemented as a `satisfies` type, hence
not recommended for performance intensive use. Main usefulness as a type
designator of the expected type in a `type-error`."
    `(and list (satisfies proper-list-p)))
  

  (deftype proper-sequence ()
    "Type designator for proper sequences, that is proper lists and sequences
that are not lists."
    `(or proper-list
         (and (not list) sequence)))
  

  (defun last-elt (sequence)
    "Returns the last element of SEQUENCE. Signals a type-error if SEQUENCE is
not a proper sequence, or is an empty sequence."
    ;; Can't just directly use ELT, as it is not guaranteed to signal the
    ;; type-error.
    (let ((len 0))
      (cond ((consp sequence)
             (lastcar sequence))
            ((and (typep sequence '(and sequence (not list))) (plusp (setf len (length sequence))))
             (elt sequence (1- len)))
            (t
             (error 'type-error
                    :datum sequence
                    :expected-type '(and proper-sequence (not (satisfies emptyp))))))))

  (defun (setf last-elt) (object sequence)
    "Sets the last element of SEQUENCE. Signals a type-error if SEQUENCE is not a proper
sequence, is an empty sequence, or if OBJECT cannot be stored in SEQUENCE."
    (let ((len 0))
      (cond ((consp sequence)
             (setf (lastcar sequence) object))
            ((and (typep sequence '(and sequence (not list))) (plusp (setf len (length sequence))))
             (setf (elt sequence (1- len)) object))
            (t
             (error 'type-error
                    :datum sequence
                    :expected-type '(and proper-sequence (not (satisfies emptyp))))))))
  

  (defparameter *looping-reduce-keywords*  '(collect! append! adjoin! sum! multiply! count! minimize! maximize!))

  (defun %extract-reduce-keywords (body)
    "Walk `body` and collect any symbol that matches any of the keywords inside
*LOOPING-REDUCE-KEYWORDS*"
    (cond ((null body) nil)
          ((symbolp body) (aif (find body *looping-reduce-keywords* :test #'string=)
                            (list it)))
          ((consp body) (unless (and (symbolp (car body))
                                     (string= (car body) 'looping))
                          (append (%extract-reduce-keywords (car body))
                                  (%extract-reduce-keywords (cdr body)))))))

  (defun %assert-compatible-reduce-keywords (keywords)
    "Assert LOOPING reduce functions `keywords` are compatible with one another
E.g. COLLECT! is compatible with APPEND!, or ADJOIN!, but not with SUM!"
    (flet ((incompatible-keyword! (k rest)
             (ecase k
               ((collect! append! adjoin!) (aif (find-if (lambda (k1) (and (not (eql k1 'collect!))
                                                                           (not (eql k1 'append!))
                                                                           (not (eql k1 'adjoin!))))
                                                         rest)
                                             (error "Cannot use ~A together with ~A" it k)))
               (sum! (aif (find 'sum! rest :test-not 'eq)
                       (error "Cannot use ~A together with ~A" it k)))
               (multiply! (aif (find 'multiply! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k)))
               (count! (aif (find 'count! rest :test-not 'eq)
                         (error "Cannot use ~A together with ~A" it k)))
               (minimize! (aif (find 'minimize! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k)))
               (maximize! (aif (find 'minimize! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k))))))
      (loop for (k . rest) on keywords do (incompatible-keyword! k rest))))

  (defun %initialize-result (keywords)
    "Initialize the LOOPING return value
 E.g. when COLLECT!-ing, the initial value will be NIL; when SUM!-ing, the
 initial value will be 0"
    (ecase (car keywords)
      ((collect! append! adjoin! minimize! maximize!) nil)
      ((sum! count!) 0)
      ((multiply!) 1)))

  (defgeneric %expand-keyword-into-label (k result last)
    (:method ((k (eql 'collect!)) result last)
      `(,(intern "COLLECT!") (item)
         (if (not ,last)
           (prog1 (push item ,result)
             (setf ,last ,result))
           (prog1 (push item (cdr ,last))
             (setf ,last (cdr ,last))))))
    (:method ((k (eql 'append!)) result last)
      `(,(intern "APPEND!") (item)
         (setf ,result (append ,result item)
               ,last (last item))
         item))
    (:method ((k (eql 'adjoin!)) result last)
      `(,(intern "ADJOIN!") (item &rest adjoin-args)
         (setf ,result (apply #'adjoin item ,result adjoin-args))))
    (:method ((k (eql 'sum!)) result last)
      `(,(intern "SUM!") (item)
         (incf ,result item)))
    (:method ((k (eql 'multiply!)) result last)
      `(,(intern "MULTIPLY!") (item)
         (setf ,result (* ,result item))))
    (:method ((k (eql 'count!)) result last)
      `(,(intern "COUNT!") (item)
         (when item
           (incf ,result))))
    (:method ((k (eql 'minimize!)) result last)
      `(,(intern "MINIMIZE!") (item)
         (setf ,result (min (or ,result item) item))))
    (:method ((k (eql 'maximize!)) result last)
      `(,(intern "MAXIMIZE!") (item)
         (setf ,result (max (or ,result item) item)))))

  (defmacro looping (&body body)
    "Run `body` in an environment where the symbols COLLECT!, APPEND!, ADJOIN!,
SUM!, MULTIPLY!, COUNT!, MINIMIZE!, and MAXIMIZE! are bound to functions that
can be used to collect / append, sum, multiply, count, minimize or maximize
things respectively.

Mixed usage of COLLECT!/APPEND!/ADJOIN!, SUM!, MULTIPLY!, COUNT!, MINIMIZE! and
MAXIMIZE! is not supported.

Examples:

  (looping
    (dotimes (i 5)
      (if (oddp i)
        (collect! i))))
  =>
  (1 3)

  (looping
    (dotimes (i 5)
      (if (oddp i)
        (sum! i))))
  =>
  4

  (looping
    (dotimes (i 5)
      (count! (oddp i))))
  =>
  2

  (looping
    (dotimes (i 5)
      (sum! i)
      (count! (oddp i))))
  ;; Signals an ERROR: Cannot use COUNT! together with SUM!
  "
    (let1 keywords (remove-duplicates (%extract-reduce-keywords body))
      (%assert-compatible-reduce-keywords keywords)
      (with-gensyms (result last expand-fn)
        (let1 labels (mapcar (lambda (k) (%expand-keyword-into-label k result last)) keywords)
          `(let* ((,result ,(%initialize-result keywords))
                  (,last nil))
             (declare (ignorable ,last))
             (labels (,@labels)
               ,@body)
             ,result)))))
  

  (defun make-keyword (name)
    "Interns the string designated by `name` in the `keyword` package."
    (intern (string name) :keyword))
  

  (defun mkstr (&rest args)
    "Receives any number of objects (string, symbol, keyword, char, number), extracts all printed representations, and concatenates them all into one string.

Extracted from _On Lisp_, chapter 4."
    (with-output-to-string (s)
      (dolist (a args) (princ a s))))
  

  (define-modify-macro mulf (&optional (ratio 2)) *
    "A modifying version of multiplication, similar to `incf`.")
  

  (defun ncycle (list)
    "Mutate `list` into a circlular list."
    (nconc list list))
  

  (defun plist-keys (plist)
    "Return all the keys of `plist`."
    (loop for k in plist by #'cddr collect k))
  

  (defun plist-values (plist)
    "Return all the values of `plist`."
    (loop for v in (cdr plist) by #'cddr collect v))
  

  (defun random-elt (sequence &key (start 0) end)
    "Returns a random element from `sequence` bounded by `start` and
`end`. Signals an error if the `sequence` is not a proper non-empty
sequence, or if `end` and `start` are not proper bounding index
designators for `sequence`."
    (declare (sequence sequence) (fixnum start) (type (or fixnum null) end))
    (let* ((size (if (listp sequence)
                     (proper-list-length sequence)
                     (length sequence)))
           (end2 (or end size)))
      (cond ((zerop size)
             (error 'type-error
                    :datum sequence
                    :expected-type `(and sequence (not (satisfies emptyp)))))
            ((not (and (<= 0 start) (< start end2) (<= end2 size)))
             (error 'simple-type-error
                    :datum (cons start end)
                    :expected-type `(cons (integer 0 (,end2))
                                          (or null (integer (,start) ,size)))
                    :format-control "~@<~S and ~S are not valid bounding index designators for ~
                                   a sequence of length ~S.~:@>"
                    :format-arguments (list start end size)))
            (t
             (let ((index (+ start (random (- end2 start)))))
               (elt sequence index))))))
  

  (defmacro recursively (bindings &body body)
    "Execute `body` recursively, like Clojure's `loop`/`recur`.

`bindings` should contain a list of symbols and (optional) starting values.

In `body` the symbol `recur` will be bound to the function for recurring."
    (let ((names (mapcar #'(lambda (b) (if (atom b) b (first b))) bindings))
          (values (mapcar #'(lambda (b) (if (atom b) nil (second b))) bindings)))
      `(labels ((,(intern "RECUR") (,@names)
                 ,@body))
         (,(intern "RECUR") ,@values))))
  

  (declaim (inline remove/swapped-arguments))
  (defun remove/swapped-arguments (sequence item &rest keyword-arguments)
    (apply #'remove item sequence keyword-arguments))

  (define-modify-macro removef (item &rest remove-keywords)
    remove/swapped-arguments
    "Modify-macro for `remove`. Sets place designated by the first argument to
the result of calling `remove` with `item`, place, and the `keyword-arguments`.")
  

  (defmacro repeat (n &body body)
    "Runs BODY N times."
    `(loop repeat ,n do ,@body))
  

  (defun shuffle (sequence &key (start 0) end)
    "Returns a random permutation of `sequence` bounded by `start` and `end`.
Original sequece may be destructively modified, and share storage with
the original one. Signals an error if `sequence` is not a proper
sequence."
    (declare (type fixnum start)
             (type (or fixnum null) end))
    (etypecase sequence
      (list
       (let* ((end (or end (proper-list-length sequence)))
              (n (- end start)))
         (do ((tail (nthcdr start sequence) (cdr tail)))
             ((zerop n))
           (rotatef (car tail) (car (nthcdr (random n) tail)))
           (decf n))))
      (vector
       (let ((end (or end (length sequence))))
         (loop for i from start below end
               do (rotatef (aref sequence i)
                           (aref sequence (+ i (random (- end i))))))))
      (sequence
       (let ((end (or end (length sequence))))
         (loop for i from (- end 1) downto start
               do (rotatef (elt sequence i)
                           (elt sequence (+ i (random (- end i)))))))))
    sequence)
  

  (defun string-ends-with-p (suffix s)
    "Returns T if the last few characters of `s` are equal to `suffix`."
    (and (<= (length suffix) (length s))
         (string= suffix s :start2 (- (length s) (length suffix)))))
  

  (defun string-starts-with-p (prefix s)
    "Returns T if the first few characters of `s` are equal to `prefix`."
    (and (<= (length prefix) (length s))
         (string= prefix s :end2 (length prefix))))
  

  (defun subdivide (sequence chunk-size)
    "Split `sequence` into subsequences of size `chunk-size`."
    (check-type sequence sequence)
    (check-type chunk-size (integer 1))
    
    (etypecase sequence
      ;; Since lists have O(N) access time, we iterate through manually,
      ;; collecting each chunk as we pass through it. Using SUBSEQ would
      ;; be O(N^2).
      (list (loop :while sequence
                  :collect
                  (loop :repeat chunk-size
                        :while sequence
                        :collect (pop sequence))))
      
      ;; For other sequences like strings or arrays, we can simply chunk
      ;; by repeated SUBSEQs.
      (sequence (loop :with len := (length sequence)
                      :for i :below len :by chunk-size
                      :collect (subseq sequence i (min len (+ chunk-size i)))))))
  

  (defun subseq- (seq &optional (start nil) (end nil))
    "Like SUBSEQ, except it supports negative indices."
    (if (not start)
      (setf start 0)
      (if (< start 0)
        (setf start (+ (length seq) start))))
    (if (not end)
      (setf end (length seq))
      (if (< end 0)
        (setf end (+ (length seq) end))))
    (subseq seq start end))
  

  (defun symb (&rest args)
    "Receives any number of objects, concatenates all into one string with `#'mkstr` and converts them to symbol.

Extracted from _On Lisp_, chapter 4.

See also: `symbolicate`"
    (values (intern (apply #'mkstr args))))
  

  (defun void (&rest args)
    "Do absolutely nothing, and return absolutely nothing."
    (declare (ignore args))
    (values))
  

  (defmacro when-let (bindings &body forms)
    "Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, then FORMS are executed as an
implicit PROGN."
    (let* ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                             (list bindings)
                             bindings))
           (variables (mapcar #'car binding-list)))
      `(let ,binding-list
         (when (and ,@variables)
           ,@forms))))

  (defmacro when-let* (bindings &body forms)
    "Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

Each initial-form is executed in turn, and the variable bound to the
corresponding value. Initial-form expressions can refer to variables
previously bound by the WHEN-LET*.

Execution of WHEN-LET* stops immediately if any initial-form evaluates to NIL.
If all initial-forms evaluate to true, then FORMS are executed as an implicit
PROGN."
    (let ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                            (list bindings)
                            bindings)))
      (labels ((bind (bindings forms)
                 (if bindings
                     `((let (,(car bindings))
                         (when ,(caar bindings)
                           ,@(bind (cdr bindings) forms))))
                     forms)))
        `(let (,(car binding-list))
           (when ,(caar binding-list)
             ,@(bind (cdr binding-list) forms))))))
  

  (defmacro when-not (test &body body)
    "Like WHEN, except TEST gets wrapped inside NOT."
    `(when (not ,test) ,@body))
  

  (defmacro while (expression &body body)
    "Executes `body` while `expression` is true."
    `(loop while ,expression do
       ,@body))
  

  (defmacro until (expression &body body)
    "Executes `body` until `expression` is true."
    `(do ()
         (,expression)
       ,@body))
  
  (abbr while-not until)

  (defmacro xor (&rest datums)
    "Evaluates its arguments one at a time, from left to right. If more than one
argument evaluates to a true value no further `datums` are evaluated, and `nil` is
returned as both primary and secondary value. If exactly one argument
evaluates to true, its value is returned as the primary value after all the
arguments have been evaluated, and `t` is returned as the secondary value. If no
arguments evaluate to true `nil` is retuned as primary, and `t` as secondary
value."
    (with-gensyms (xor tmp true)
      `(let (,tmp ,true)
         (block ,xor
           ,@(mapcar (lambda (datum)
                       `(if (setf ,tmp ,datum)
                            (if ,true
                                (return-from ,xor (values nil nil))
                                (setf ,true ,tmp))))
                     datums)
           (return-from ,xor (values ,true t))))))
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (export '(keep-if keep-if-not aand aif alist-keys alist-values appendf
            assoc-value rassoc-value awhen bnd* bnd1 copy-array copy-hash-table
            defaccessor accesses digits divf doalist dohash dolists dorange
            dorangei doseq doseqs dosublists enumerate flatten hash-table-alist
            hash-table-key-exists-p hash-table-keys hash-table-values if-let
            if-not iota last-elt looping make-keyword mkstr mulf ncycle
            plist-keys plist-values random-elt recursively removef repeat
            shuffle string-ends-with-p string-starts-with-p subdivide subseq-
            symb void when-let when-let* when-not while while-not with-gensyms
            with-unique-names xor)))

;;;; END OF quickutils.lisp ;;;;
