;;;; This file was automatically generated by Quickutil.
;;;; See http://quickutil.org for details.

;;;; To regenerate:
;;;; (qtlc:save-utils-as "quickutils.lisp" :utilities '(:@ :AAND :AIF :ALIST :ALIST-KEYS :ALIST-VALUES :APPENDF :APROG1 :ASSOC-VALUE :AWHEN :BND* :BND1 :COPY-ARRAY :COPY-HASH-TABLE :DBG :DBGL :DEFACCESSOR :DIGITS :DIVF :DOALIST :DOHASH :DOHASHK :DOHASHV :DOLISTS :DORANGE :DORANGEI :DOSEQ :DOSEQS :DOSUBLISTS :ENUMERATE :FLATTEN :FN :HASH-TABLE-ALIST :HASH-TABLE-KEY-EXISTS-P :HASH-TABLE-KEYS :HASH-TABLE-VALUES :IF-LET :IF-NOT :IOTA :KEEP-IF :KEEP-IF-NOT :LAST-ELT :LET1 :LOOPING :MAKE-KEYWORD :MKLIST :MKSTR :MULF :NCYCLE :PARTITION-IF :PLIST-KEYS :PLIST-VALUES :PMX :PR :PRN :PROG1-LET :PRS :PSX :RANDOM-ELT :RECURSIVELY :REMOVEF :REPEAT :RETRIABLE :SHUFFLE :SPR :SPRN :SPRS :STRING-ENDS-WITH-P :STRING-STARTS-WITH-P :SUBDIVIDE :SUBSEQ- :SYMB :TAKE :UNDEFCLASS :UNDEFCONSTANT :UNDEFMACRO :UNDEFMETHOD :UNDEFPACKAGE :UNDEFPARAMETER :UNDEFUN :UNDEFVAR :UNTIL :VALUE-AT :VOID :WHEN-LET :WHEN-NOT :WHILE :WHILE-NOT :WITH-GENSYMS :XOR :ZAPF :~>) :ensure-package T :package "AOC.QUICKUTILS")

(eval-when (:compile-toplevel :load-toplevel :execute)
  (unless (find-package "AOC.QUICKUTILS")
    (defpackage "AOC.QUICKUTILS"
      (:documentation "Package that contains Quickutil utility functions.")
      (:use #:cl))))

(in-package "AOC.QUICKUTILS")

(when (boundp '*utilities*)
  (setf *utilities* (union *utilities* '(:STRING-DESIGNATOR :WITH-GENSYMS
                                         :ASSOC-VALUE :VALUE-AT :@ :LET1 :AIF
                                         :AAND :ALIST :ALIST-KEYS :ALIST-VALUES
                                         :APPENDF :APROG1 :AWHEN :BND* :BND1
                                         :COPY-ARRAY :COPY-HASH-TABLE :DBG
                                         :DBGL :PARSE-BODY :DEFACCESSOR :DIGITS
                                         :DIVF :MAKE-GENSYM-LIST :ONCE-ONLY
                                         :DOALIST :DOHASH :DOHASHK :DOHASHV
                                         :DOLISTS :DORANGE :DORANGEI :DOSEQ
                                         :DOSEQS :DOSUBLISTS :ENUMERATE
                                         :FLATTEN :FN :HASH-TABLE-ALIST
                                         :HASH-TABLE-KEY-EXISTS-P :MAPHASH-KEYS
                                         :HASH-TABLE-KEYS :MAPHASH-VALUES
                                         :HASH-TABLE-VALUES :IF-LET :IF-NOT
                                         :IOTA :ABBR :KEEP-IF :KEEP-IF-NOT
                                         :NON-ZERO-P :EMPTYP :SAFE-ENDP
                                         :CIRCULAR-LIST
                                         :PROPER-LIST-LENGTH/LAST-CAR
                                         :PROPER-LIST-P :PROPER-LIST
                                         :PROPER-SEQUENCE :LAST-ELT :LOOPING
                                         :MAKE-KEYWORD :MKLIST :MKSTR :MULF
                                         :NCYCLE :PARTITION-IF :PLIST-KEYS
                                         :PLIST-VALUES :PMX :PR :PRN :PROG1-LET
                                         :PRS :PSX :RANDOM-ELT :RECURSIVELY
                                         :REMOVEF :REPEAT :RETRIABLE :SHUFFLE
                                         :SPR :SPRN :SPRS :STRING-ENDS-WITH-P
                                         :STRING-STARTS-WITH-P :SUBDIVIDE
                                         :SUBSEQ- :SYMB :TAKE :UNDEFCLASS
                                         :UNDEFCONSTANT :UNDEFMACRO
                                         :UNDEFMETHOD :UNDEFPACKAGE
                                         :UNDEFPARAMETER :UNDEFUN :UNDEFVAR
                                         :UNTIL :VOID :WHEN-LET :WHEN-NOT
                                         :WHILE :WHILE-NOT :XOR :ZAPF :~>))))

  (deftype string-designator ()
    "A string designator type. A string designator is either a string, a symbol,
or a character."
    `(or symbol string character))
  

  (defmacro with-gensyms (names &body forms)
    "Binds each variable named by a symbol in `names` to a unique symbol around
`forms`. Each of `names` must either be either a symbol, or of the form:

    (symbol string-designator)

Bare symbols appearing in `names` are equivalent to:

    (symbol symbol)

The string-designator is used as the argument to `gensym` when constructing the
unique symbol the named variable will be bound to."
    `(let ,(mapcar (lambda (name)
                     (multiple-value-bind (symbol string)
                         (etypecase name
                           (symbol
                            (values name (symbol-name name)))
                           ((cons symbol (cons string-designator null))
                            (values (first name) (string (second name)))))
                       `(,symbol (gensym ,string))))
            names)
       ,@forms))

  (defmacro with-unique-names (names &body forms)
    "Binds each variable named by a symbol in `names` to a unique symbol around
`forms`. Each of `names` must either be either a symbol, or of the form:

    (symbol string-designator)

Bare symbols appearing in `names` are equivalent to:

    (symbol symbol)

The string-designator is used as the argument to `gensym` when constructing the
unique symbol the named variable will be bound to."
    `(with-gensyms ,names ,@forms))
  

  (declaim (inline racons))
  (defun racons (key value ralist)
    (acons value key ralist))
  
  (macrolet
      ((define-alist-get (name get-entry get-value-from-entry add doc)
         `(progn
            (declaim (inline ,name))
            (defun ,name (alist key &key (test 'equal))
              ,doc
              (let ((entry (,get-entry key alist :test test)))
                (values (,get-value-from-entry entry) entry)))
            (define-setf-expander ,name (place key &key (test ''equal)
                                                   &environment env)
              (multiple-value-bind
                    (temporary-variables initforms newvals setter getter)
                  (get-setf-expansion place env)
                (when (cdr newvals)
                  (error "~A cannot store multiple values in one place" ',name))
                (with-unique-names (new-value key-val test-val alist entry)
                  (values
                   (append temporary-variables
                           (list alist
                                 key-val
                                 test-val
                                 entry))
                   (append initforms
                           (list getter
                                 key
                                 test
                                 `(,',get-entry ,key-val ,alist :test ,test-val)))
                   `(,new-value)
                   `(cond
                      (,entry
                       (setf (,',get-value-from-entry ,entry) ,new-value))
                      (t
                       (let ,newvals
                         (setf ,(first newvals) (,',add ,key ,new-value ,alist))
                         ,setter
                         ,new-value)))
                   `(,',get-value-from-entry ,entry))))))))
    
    (define-alist-get assoc-value assoc cdr acons
      "ASSOC-VALUE is an alist accessor very much like ASSOC, but it can
be used with SETF.")
    
    (define-alist-get rassoc-value rassoc car racons
      "RASSOC-VALUE is an alist accessor very much like RASSOC, but it can
be used with SETF."))
  

  (defgeneric value-at (x place)
    (:documentation "Returns the value of the place `place` inside `x`.  Also SETF-able.

If `x` is an STANDARD-OBJECT, this method will delegate to SLOT-VALUE.
If `x` is a LIST and `place` is NUMBER, this method will delegate to NTH.
If `x` is a LIST and `place` is STRING, this method will delegate to ASSOC-VALUE.
If `x` is a LIST and `place` is SYMBOL, this method will delegate to GETF.
If `x` is a HASH-TABLE, this method will delegate to GETHASH.
If `x` is an ARRAY, this method will delegate to AREF.
")
    (:method ((x standard-object) slot)  (slot-value x slot))
    (:method ((x list) (n number))  (nth n x))
    (:method ((x list) (key string))  (assoc-value x key))
    (:method ((x list) (prop symbol))  (getf x prop))
    (:method ((x hash-table) key)  (gethash key x))
    ;; FIXME: add support for multiple subscripts
    (:method ((x array) subscript) (aref x subscript)))

  (defgeneric (setf value-at) (value x place)
    (:method (value (x standard-object) slot)  (setf (slot-value x slot) value))
    (:method (value (x list) (n number))  (setf (nth n x) value))
    (:method (value (x list) (key string))  (setf (assoc-value x key) value))
    (:method (value (x list) (prop symbol))  (setf (getf x prop) value))
    (:method (value (x hash-table) key)  (setf (gethash key x) value))
    ;; FIXME: add support for multiple subscripts
    (:method (value (x array) subscript) (setf (aref x subscript) value)))
  

  (defmacro @ (x &rest places)
    ;;"XXX"
    (setf places (reverse places))
    (labels ((recur (places)
               (if (not (cdr places))
                 `(value-at ,x ,(first places))
                 `(value-at ,(recur (cdr places))
                    ',(first places)))))
      (recur places)))
  

  (defmacro let1 (var val &body body)
    "Bind VAR to VAL within BODY. Equivalent to LET with one binding."
    `(let ((,var ,val))
       ,@body))
  

  (defmacro aif (test then &optional else)
    "Like IF, except binds the result of `test` to IT (via LET) for the scope of `then` and `else` expressions."
    (aif-expand test then else))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun aif-expand (test then &optional else)
      (let1 it (intern "IT")
        `(let1 ,it ,test
           (if ,it ,then ,else)))))
  

  (defmacro aand (&rest forms)
    "Like AND, except binds the result of each form to IT (via LET)."
    (aand-expand forms))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun aand-expand (forms)
      (cond ((not (car forms)) nil)
            ((not (cdr forms)) (car forms))
            (t (let1 car (car forms)
                 `(aif ,car
                    (aand ,@(cdr forms))))))))
  

  (defun alist (key value &rest key-values)
    (list* (cons key value)
           (loop :for (key value) :on key-values :by #'cddr
                 :collect (cons key value))))
  

  (defun alist-keys (alist)
    "Return all the keys of `alist`."
    (mapcar #'car alist))
  

  (defun alist-values (alist)
    "Return all the values of `alist`."
    (mapcar #'cdr alist))
  

  (define-modify-macro appendf (&rest lists) append
    "Modify-macro for `append`. Appends `lists` to the place designated by the first
argument.")
  

  (defmacro aprog1 (result-form &body body)
    "Like PROG1, except binds the result of the `result-form` (i.e., the returned
form) to IT (via LET) for the scope of `body`.

Inspired by ActiveSupport: Object#returning
https://weblog.jamisbuck.org/2006/10/27/mining-activesupport-object-returning.html"
    (aprog1-expand result-form body))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun aprog1-expand (result-form body)
      (let1 it (intern "IT")
        `(let1 ,it ,result-form
           ,@body
           ,it))))
  

  (defmacro awhen (test &body body)
    "Like WHEN, except binds the result of `test` to IT (via LET) for the scope of `body`."
    (awhen-expand test body))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun awhen-expand (test body)
      (let1 it (intern "IT")
        `(let1 ,it ,test
           (when ,it
             ,@body)))))
  

  (defmacro bnd* (bindings &body body)
    "Like LET*, but more powerful.

Use a symbol as the name of the binding to expand to a standard LET:

(bnd* (x
       (y (list 1 2 3)))
  (list x y)) ≡
(let (x)
  (let ((y (list 1 2 3)))
    (list x y)))

Use a list as the name of the binding to enable special type of expansions.

If the CAR of the list is the symbol VALUES, expand to MULTIPLE-VALUE-BIND
call:

(bnd* (((values f r) (floor 130 11)))
  (list f r)) ≡
(multiple-value-bind (f r)
     (floor 130 11)
   (list f r))

If the CAR of the list is the symbol WITH-SLOTS, expand to a WITH-SLOTS call:

(bnd* (((with-slots x y) thing))
  (incf x) (incf y))
≡
(with-slots (x y) thing
  (incf x) (incf y))

Otherwise, if the name of the binding is a list but none of the above applies,
BND* will expand to a DESTRUCTURING-BIND call:

(bnd* (((a b) '(1 2)))
  (list a b))
≡
(destructuring-bind (a b)
    '(1 2)
  (list a b))"
    (labels ((mklist (x) (if (atom x) (list x) x))
             (expand (bb)
               (cond ((null bb) (signal 'unexpected))
                     (t (let* ((b (mklist (car bb)))
                               (var (car b))
                               (val (cadr b)))
                          (cond ((symbolp var)
                                 `(let (,b)
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                ((eq (car var) 'values)
                                 `(multiple-value-bind ,(rest var) ,val
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                ((eq (car var) 'with-slots)
                                 `(with-slots ,(rest var) ,val
                                    ,@(if (rest bb)
                                        (list (expand (rest bb)))
                                        body)))
                                (t `(destructuring-bind ,@b
                                      ,@(if (rest bb)
                                          (list (expand (rest bb)))
                                          body)))))))))
      (expand bindings)))
  

  (defmacro bnd1 (var val &body body)
    "BND1 is to BND* like LET1 is to LET*."
    `(bnd* ((,var ,val))
       ,@body))
  

  (defun copy-array (array &key (element-type (array-element-type array))
                                (fill-pointer (and (array-has-fill-pointer-p array)
                                                   (fill-pointer array)))
                                (adjustable (adjustable-array-p array)))
    "Returns an undisplaced copy of `array`, with same `fill-pointer` and
adjustability (if any) as the original, unless overridden by the keyword
arguments."
    (let* ((dimensions (array-dimensions array))
           (new-array (make-array dimensions
                                  :element-type element-type
                                  :adjustable adjustable
                                  :fill-pointer fill-pointer)))
      (dotimes (i (array-total-size array))
        (setf (row-major-aref new-array i)
              (row-major-aref array i)))
      new-array))
  

  (defun copy-hash-table (table &key key test size
                                     rehash-size rehash-threshold)
    "Returns a copy of hash table `table`, with the same keys and values
as the `table`. The copy has the same properties as the original, unless
overridden by the keyword arguments.

Before each of the original values is set into the new hash-table, `key`
is invoked on the value. As `key` defaults to `cl:identity`, a shallow
copy is returned by default."
    (setf key (or key 'identity))
    (setf test (or test (hash-table-test table)))
    (setf size (or size (hash-table-size table)))
    (setf rehash-size (or rehash-size (hash-table-rehash-size table)))
    (setf rehash-threshold (or rehash-threshold (hash-table-rehash-threshold table)))
    (let ((copy (make-hash-table :test test :size size
                                 :rehash-size rehash-size
                                 :rehash-threshold rehash-threshold)))
      (maphash (lambda (k v)
                 (setf (gethash k copy) (funcall key v)))
               table)
      copy))
  

  (defun dbg (&rest args)
    "Print `args` to screen, separated by a space, and followed by a newline.
Returns the first arg."
    (format t "~{~A~^ ~}" args)
    (terpri)
    (finish-output)
    (first args))
  

  (defmacro dbgl (&rest args)
    "Print `args`, labeled, separated by a newline, and followed by a final
newline.  Returns the last arg. labeled and readably."
    `(prog1
       (progn ,@(mapcar (lambda (arg) `(dbg ',arg ,arg)) args))
       (terpri)
       (finish-output)))
  

  (defun parse-body (body &key documentation whole)
    "Parses `body` into `(values remaining-forms declarations doc-string)`.
Documentation strings are recognized only if `documentation` is true.
Syntax errors in body are signalled and `whole` is used in the signal
arguments when given."
    (let ((doc nil)
          (decls nil)
          (current nil))
      (tagbody
       :declarations
         (setf current (car body))
         (when (and documentation (stringp current) (cdr body))
           (if doc
               (error "Too many documentation strings in ~S." (or whole body))
               (setf doc (pop body)))
           (go :declarations))
         (when (and (listp current) (eql (first current) 'declare))
           (push (pop body) decls)
           (go :declarations)))
      (values body (nreverse decls) doc)))
  

  (defmacro defaccessor (name lambda-list &body body)
    "Define the function named `name` just as with a normal `defun`. Also define the setter `(setf name)`. The form to be set (i.e., the place) should be wrapped in the local macro `accesses`. For example,

```
  CL-USER> (let ((x 0))
             (defaccessor saved-x ()
               (accesses x)))
  SAVED-X
  (SETF SAVED-X)
  CL-USER> (saved-x)
  0
  CL-USER> (setf (saved-x) 5)
  5
  CL-USER> (saved-x)
  5
```
"
    (multiple-value-bind (remaining-forms decls doc)
        (parse-body body :documentation t)
      (with-gensyms (new-value)
        `(progn
           (defun ,name ,lambda-list
             ,doc
             ,@decls
             (macrolet ((accesses (form)
                          form))
               ,@remaining-forms))
         
           (defun (setf ,name) ,(cons new-value lambda-list)
             ,(format nil "Setter for the function ~S." name)
             ,@decls
             (macrolet ((accesses (form)
                          `(setf ,form ,',new-value)))
               ,@remaining-forms
               ,new-value))
           (values
            ',name
            '(setf ,name))))))
  

  (defun digits (n &optional (base 10))
    "Return a list of the digits of the non-negative integer `n` in base
`base`. By default, decimal digits are returned.

The order of the digits is such that the `k`th element of the list refers to the coefficient of `base^k`. In other words, given the resulting list

    (c0 c1 c2 ... ck)

the following identity holds:

    n = c0 + c1*base + c2*base^2 + ... + ck*base^k."
    (check-type n (integer 0))
    (check-type base (integer 2))
    (loop :with remainder
          :do (setf (values n remainder) (truncate n base))
          :collect remainder
          :until (zerop n)))
  

  (define-modify-macro divf (&optional (1/ratio 2)) /
    "A modifying version of division, similar to `decf`.")
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun make-gensym-list (length &optional (x "G"))
    "Returns a list of `length` gensyms, each generated as if with a call to `make-gensym`,
using the second (optional, defaulting to `\"G\"`) argument."
    (let ((g (if (typep x '(integer 0)) x (string x))))
      (loop repeat length
            collect (gensym g))))
  )                                        ; eval-when

  (defmacro once-only (specs &body forms)
    "Evaluates `forms` with symbols specified in `specs` rebound to temporary
variables, ensuring that each initform is evaluated only once.

Each of `specs` must either be a symbol naming the variable to be rebound, or of
the form:

    (symbol initform)

Bare symbols in `specs` are equivalent to

    (symbol symbol)

Example:

    (defmacro cons1 (x) (once-only (x) `(cons ,x ,x)))
      (let ((y 0)) (cons1 (incf y))) => (1 . 1)"
    (let ((gensyms (make-gensym-list (length specs) "ONCE-ONLY"))
          (names-and-forms (mapcar (lambda (spec)
                                     (etypecase spec
                                       (list
                                        (destructuring-bind (name form) spec
                                          (cons name form)))
                                       (symbol
                                        (cons spec spec))))
                                   specs)))
      ;; bind in user-macro
      `(let ,(mapcar (lambda (g n) (list g `(gensym ,(string (car n)))))
              gensyms names-and-forms)
         ;; bind in final expansion
         `(let (,,@(mapcar (lambda (g n)
                             ``(,,g ,,(cdr n)))
                           gensyms names-and-forms))
            ;; bind in user-macro
            ,(let ,(mapcar (lambda (n g) (list (car n) g))
                    names-and-forms gensyms)
               ,@forms)))))
  

  (defmacro doalist ((key val alist &optional (result nil result?)) &body body)
    "Iterates over the elements of `alist`."
    (once-only (alist)
      `(loop :for (,key . ,val) :in ,alist :do ,@body ,@(when result? `(:finally (return ,result))))))
  

  (defmacro dohash ((key value table &optional (result nil result?)) &body body)
    "Iterate over the hash table `table`, executing `body`, with `key` and
   `value` bound to the keys and values of the hash table
   respectively. Return `result` from the iteration form."
    `(loop :for ,key :being :the :hash-keys :of ,table :using (hash-value ,value) :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defmacro dohashk ((key table &optional (result nil result?)) &body body)
    "Iterate over the hash table `table`, executing `body`, with
`key` bound to the keys of the hash table.

Return `result` from the iteration form."
    `(loop
       :for ,key :being :the :hash-keys :of ,table
       :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defmacro dohashv ((value table &optional (result nil result?)) &body body)
    "Iterate over the hash table `table`, executing `body`, with 
`value` bound to the values of the hash table.

Return `result` from the iteration form."
    `(loop
       :for ,value :being :the :hash-values :of ,table 
       :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defmacro dolists (((var1 list1) (var2 list2) &rest var-list-specs) &body body)
    "Like DOLIST, except it allows you to iterate over multiple lists in parallel.

  > (let ((list '(1 2 3 4)))
      (dolists ((x1 list)
                (x2 (cdr list)))
        (print (list x1 x2))))
  ;; (1 2)
  ;; (2 3)
  ;; (3 4)
  NIL
  "
    `(loop
       :for ,var1 :in ,list1 :for ,var2 :in ,list2
       ,@(loop for (var list) in var-list-specs
               collect 'FOR collect var collect 'IN collect list)
       :do ,@body))
  

  (defmacro dorange ((var from to &optional (step 1) (result nil result?)) &body body)
    "Binds `var` to all the distinct values in the range [`from`, `to`[, with
`step` step (note: `to` is excluded), and runs `body` inside that
lexical environmnet."
    (let ((step-g (gensym "step"))
          (to-g (gensym "to")))
      `(do* ((,step-g ,step)
             (,to-g ,to)
             (,var ,from (+ ,var ,step-g)))
         ((if (>= ,step-g 0) (>= ,var ,to-g) (<= ,var ,to-g))
          ,@(when result? `(,result)))
         ,@body)))
  

  (defmacro dorangei ((var from to &optional (step 1) (result nil result?)) &body body)
    "Like DORANGE, `to` is inclusive (the range is: [`from`, `to`])."
    (let ((step-g (gensym "step"))
          (to-g (gensym "to")))
      `(do* ((,step-g ,step)
             (,to-g ,to)
             (,var ,from (+ ,var ,step-g)))
         ((if (>= ,step-g 0) (> ,var ,to-g) (< ,var ,to-g))
          ,@(when result? `(,result)))
         ,@body)))
  

  (defmacro doseq ((var seq &optional (result nil result?)) &body body)
    "Iterate across the sequence `seq`, binding the variable `var` to
each element of the sequence and executing `body`. Return the value
`return` from the iteration form.

Note: DOSEQ expands to a LOOP form, so `var` can either be a symbol, or a
lambda-list"
    (once-only (seq)
      `(etypecase ,seq
         (list (loop :for ,var :in ,seq :do ,@body ,@(when result? `(:finally (return ,result)))))
         (sequence (loop :for ,var :across ,seq :do ,@body ,@(when result? `(:finally (return ,result))))))))
  

  (defmacro doseqs (((var1 seq1) (var2 seq2) &rest var-seq-specs) &body body)
    "Like DOSEQ, except this can iterate over multiple sequences at the same
time."
    (let* ((vars (list* var1 var2 (mapcar #'car var-seq-specs)))
           (seqs (list* seq1 seq2 (mapcar #'cadr var-seq-specs))))

      `(block nil
         (map nil (lambda (,@vars) ,@body) ,@seqs))))
  

  (defmacro dosublists ((var list &optional (result nil result?)) &body body)
    "Like DOLIST, except:

- `var` is bound to successive sublists of `list` (similar to MAPL, LOOP..ON)
- `var` can be a lambda-list
"
    `(loop :for ,var :on ,list :do ,@body ,@(when result? `(:finally (return ,result)))))
  

  (defgeneric enumerate (x &key start)
    (:documentation "Equivalent to `(zip (iota (length x)) x)`."))

  (defmethod enumerate ((x list) &key (start 0))
    "Equivalent to `(zip (iota (length x)) x)`."
    (loop
      :for i :in x
      :for j :from start
      :collect (list j i)))

  (defmethod enumerate ((x array) &key (start 0))
    "Equivalent to `(zip (iota (length x)) x)`."
    (loop
      :for i :across x
      :for j :from start
      :collect (list j i)))
  

  (defun flatten (&rest xs)
    "Flatten (and append) all lists `xs` completely."
    (labels ((rec (xs acc)
               (cond ((null xs)  acc)
                     ((consp xs) (rec (car xs) (rec (cdr xs) acc)))
                     (t          (cons xs acc)))))
      (rec xs nil)))
  

  (defmacro fn (lambda-list &body body)
    "Like LAMBDA, but 4 characters shorter."
    `(lambda ,lambda-list ,@body))
  

  (defun hash-table-alist (table)
    "Returns an association list containing the keys and values of hash table
`table`."
    (let ((alist nil))
      (maphash (lambda (k v)
                 (push (cons k v) alist))
               table)
      alist))
  

  (defun hash-table-key-exists-p (hash-table key)
    "Does `key` exist in `hash-table`?"
    (nth-value 1 (gethash key hash-table)))
  

  (declaim (inline maphash-keys))
  (defun maphash-keys (function table)
    "Like `maphash`, but calls `function` with each key in the hash table `table`."
    (maphash (lambda (k v)
               (declare (ignore v))
               (funcall function k))
             table))
  

  (defun hash-table-keys (table)
    "Returns a list containing the keys of hash table `table`."
    (let ((keys nil))
      (maphash-keys (lambda (k)
                      (push k keys))
                    table)
      keys))
  

  (declaim (inline maphash-values))
  (defun maphash-values (function table)
    "Like `maphash`, but calls `function` with each value in the hash table `table`."
    (maphash (lambda (k v)
               (declare (ignore k))
               (funcall function v))
             table))
  

  (defun hash-table-values (table)
    "Returns a list containing the values of hash table `table`."
    (let ((values nil))
      (maphash-values (lambda (v)
                        (push v values))
                      table)
      values))
  

  (defmacro if-let (bindings &body (then-form &optional else-form))
    "Creates new variable bindings, and conditionally executes either
`then-form` or `else-form`. `else-form` defaults to `nil`.

`bindings` must be either single binding of the form:

    (variable initial-form)

or a list of bindings of the form:

    ((variable-1 initial-form-1)
     (variable-2 initial-form-2)
     ...
     (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, the `then-form` is executed with the
bindings in effect, otherwise the `else-form` is executed with the bindings in
effect."
    (let* ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                             (list bindings)
                             bindings))
           (variables (mapcar #'car binding-list)))
      `(let ,binding-list
         (if (and ,@variables)
             ,then-form
             ,else-form))))
  

  (defmacro if-not (test then &optional else)
    "Like IF, except TEST gets wrapped inside NOT."
    `(if (not ,test) ,then ,else))
  

  (declaim (inline iota))
  (defun iota (n &key (start 0) (step 1))
    "Return a list of `n` numbers, starting from `start` (with numeric contagion
from `step` applied), each consequtive number being the sum of the previous one
and `step`. `start` defaults to `0` and `step` to `1`.

Examples:

    (iota 4)                      => (0 1 2 3)
    (iota 3 :start 1 :step 1.0)   => (1.0 2.0 3.0)
    (iota 3 :start -1 :step -1/2) => (-1 -3/2 -2)"
    (declare (type (integer 0) n) (number start step))
    (loop repeat n
          ;; KLUDGE: get numeric contagion right for the first element too
          for i = (+ (- (+ start step) step)) then (+ i step)
          collect i))
  

  (defmacro abbr (short long)
    "Defines a new function/macro named `short` and sharing
FDEFINITION/MACRO-FUNCTION with `long`."
    `(eval-when (:compile-toplevel :load-toplevel :execute)
       (cond
         ((macro-function ',long)
          (setf (macro-function ',short) (macro-function ',long))
          #+ccl (setf (ccl:arglist ',short) (ccl:arglist ',long)))
         ((fboundp ',long)
          (setf (fdefinition ',short) (fdefinition ',long))
          #+ccl (setf (ccl:arglist ',short) (ccl:arglist ',long)))
         (t
           (error "Can't abbreviate ~a" ',long)))))
  
  (abbr keep-if remove-if-not)
  (abbr keep-if-not remove-if)

  (defun non-zero-p (n)
    "Check if `n` is non-zero."
    (not (zerop n)))
  

  (defgeneric emptyp (object)
    (:documentation "Determine if `object` is empty.")
    (:method ((x null)) t)
    (:method ((x cons)) nil)
    (:method ((x vector)) (zerop (length x))) ; STRING :< VECTOR
    (:method ((x array)) (notany #'non-zero-p (array-dimensions x)))
    (:method ((x hash-table)) (zerop (hash-table-count x))))
  

  (declaim (inline safe-endp))
  (defun safe-endp (x)
    (declare (optimize safety))
    (endp x))
  

  (defun circular-list (&rest elements)
    "Creates a circular list of ELEMENTS."
    (let ((cycle (copy-list elements)))
      (nconc cycle cycle)))

  (defun circular-list-p (object)
    "Returns true if OBJECT is a circular list, NIL otherwise."
    (and (listp object)
         (do ((fast object (cddr fast))
              (slow (cons (car object) (cdr object)) (cdr slow)))
             (nil)
           (unless (and (consp fast) (listp (cdr fast)))
             (return nil))
           (when (eq fast slow)
             (return t)))))
  
  (defun make-circular-list (length &key initial-element)
    "Creates a circular list of LENGTH with the given INITIAL-ELEMENT."
    (let ((cycle (make-list length :initial-element initial-element)))
      (nconc cycle cycle)))

  (deftype circular-list ()
    "Type designator for circular lists. Implemented as a SATISFIES type, so not
recommended for performance intensive use. Main usefullness as the
expected-type designator of a TYPE-ERROR."
    `(satisfies circular-list-p))
  

  (defun circular-list-error (list)
    (error 'type-error
           :datum list
           :expected-type '(and list (not circular-list))))
  
  (macrolet ((def (name lambda-list doc step declare ret1 ret2)
               (assert (member 'list lambda-list))
               `(defun ,name ,lambda-list
                  ,doc
                  (do ((last list fast)
                       (fast list (cddr fast))
                       (slow (cons (car list) (cdr list)) (cdr slow))
                       ,@(when step (list step)))
                      (nil)
                    (declare (dynamic-extent slow) ,@(when declare (list declare))
                             (ignorable last))
                    (when (safe-endp fast)
                      (return ,ret1))
                    (when (safe-endp (cdr fast))
                      (return ,ret2))
                    (when (eq fast slow)
                      (circular-list-error list))))))
    (def proper-list-length (list)
      "Returns length of LIST, signalling an error if it is not a proper list."
      (n 1 (+ n 2))
      ;; KLUDGE: Most implementations don't actually support lists with bignum
      ;; elements -- and this is WAY faster on most implementations then declaring
      ;; N to be an UNSIGNED-BYTE.
      (fixnum n)
      (1- n)
      n)

    (def lastcar (list)
      "Returns the last element of LIST. Signals a type-error if LIST is not a
proper list."
      nil
      nil
      (cadr last)
      (car fast))

    (def (setf lastcar) (object list)
      "Sets the last element of LIST. Signals a type-error if LIST is not a proper
list."
      nil
      nil
      (setf (cadr last) object)
      (setf (car fast) object)))
  

  (defun proper-list-p (object)
    "Returns true if `object` is a proper list."
    (cond ((not object)
           t)
          ((consp object)
           (do ((fast object (cddr fast))
                (slow (cons (car object) (cdr object)) (cdr slow)))
               (nil)
             (unless (and (listp fast) (consp (cdr fast)))
               (return (and (listp fast) (not (cdr fast)))))
             (when (eq fast slow)
               (return nil))))
          (t
           nil)))
  

  (deftype proper-list ()
    "Type designator for proper lists. Implemented as a `satisfies` type, hence
not recommended for performance intensive use. Main usefulness as a type
designator of the expected type in a `type-error`."
    `(and list (satisfies proper-list-p)))
  

  (deftype proper-sequence ()
    "Type designator for proper sequences, that is proper lists and sequences
that are not lists."
    `(or proper-list
         (and (not list) sequence)))
  

  (defun last-elt (sequence)
    "Returns the last element of SEQUENCE. Signals a type-error if SEQUENCE is
not a proper sequence, or is an empty sequence."
    ;; Can't just directly use ELT, as it is not guaranteed to signal the
    ;; type-error.
    (let ((len 0))
      (cond ((consp sequence)
             (lastcar sequence))
            ((and (typep sequence '(and sequence (not list))) (plusp (setf len (length sequence))))
             (elt sequence (1- len)))
            (t
             (error 'type-error
                    :datum sequence
                    :expected-type '(and proper-sequence (not (satisfies emptyp))))))))

  (defun (setf last-elt) (object sequence)
    "Sets the last element of SEQUENCE. Signals a type-error if SEQUENCE is not a proper
sequence, is an empty sequence, or if OBJECT cannot be stored in SEQUENCE."
    (let ((len 0))
      (cond ((consp sequence)
             (setf (lastcar sequence) object))
            ((and (typep sequence '(and sequence (not list))) (plusp (setf len (length sequence))))
             (setf (elt sequence (1- len)) object))
            (t
             (error 'type-error
                    :datum sequence
                    :expected-type '(and proper-sequence (not (satisfies emptyp))))))))
  

  (defparameter *looping-reduce-keywords*  '(collect! append!
                                             adjoin!
                                             push!
                                             sum! multiply!
                                             count!
                                             minimize!
                                             maximize!
                                             always!
                                             never!
                                             thereis!
                                             spr!))

  (defun %extract-reduce-keywords (body)
    "Walk `body` and collect any symbol that matches any of the keywords inside
*LOOPING-REDUCE-KEYWORDS*"
    (cond ((null body) nil)
          ((symbolp body) (aif (find body *looping-reduce-keywords* :test #'string=)
                            (list it)))
          ((consp body) (unless (and (symbolp (car body))
                                     (string= (car body) 'looping))
                          (append (%extract-reduce-keywords (car body))
                                  (%extract-reduce-keywords (cdr body)))))))

  (defun %assert-compatible-reduce-keywords (keywords)
    "Assert LOOPING reduce functions `keywords` are compatible with one another
E.g. COLLECT! is compatible with APPEND!, but not with SUM!"
    (flet ((incompatible-keyword! (k rest)
             (ecase k
               ((collect! append!)
                (aif (find-if (lambda (k1) (and (not (eql k1 'collect!))
                                                (not (eql k1 'append!))))
                              rest)
                  (error "Cannot use ~A together with ~A" it k)))
               (adjoin!  (aif (find 'adjoin! rest :test-not 'eq)
                           (error "Cannot use ~A together with ~A" it k)))
               (push!  (aif (find 'push! rest :test-not 'eq)
                         (error "Cannot use ~A together with ~A" it k)))
               (sum! (aif (find 'sum! rest :test-not 'eq)
                       (error "Cannot use ~A together with ~A" it k)))
               (multiply! (aif (find 'multiply! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k)))
               (count! (aif (find 'count! rest :test-not 'eq)
                         (error "Cannot use ~A together with ~A" it k)))
               (minimize! (aif (find 'minimize! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k)))
               (maximize! (aif (find 'maximize! rest :test-not 'eq)
                            (error "Cannot use ~A together with ~A" it k)))
               (always! (aif (find 'always! rest :test-not 'eq)
                          (error "Cannot use ~A together with ~A" it k)))
               (never! (aif (find 'never! rest :test-not 'eq)
                         (error "Cannot use ~A together with ~A" it k)))
               (thereis! (aif (find 'thereis! rest :test-not 'eq)
                           (error "Cannot use ~A together with ~A" it k)))
               (spr! (aif (find 'spr! rest :test-not 'eq)
                       (error "Cannot use ~A together with ~A" it k))))))
      (loop for (k . rest) on keywords do (incompatible-keyword! k rest))))

  (defun %initialize-result (keywords)
    "Initialize the LOOPING return value
 E.g. when COLLECT!-ing, the initial value will be NIL; when SUM!-ing, the
 initial value will be 0"
    (ecase (car keywords)
      ((collect! append! adjoin! push! minimize! maximize!) nil)
      ((sum! count!) 0)
      (multiply! 1)
      (always! t)
      (never! t)
      (thereis! nil)
      (spr! "")))

  (defgeneric %expand-keyword-into-label (k result last short-circuit-tag)
    (:method ((k (eql 'collect!)) result last short-circuit-tag)
      `(,(intern "COLLECT!") (item)
         (if (not ,last)
           (prog1 (push item ,result)
             (setf ,last ,result))
           (prog1 (push item (cdr ,last))
             (setf ,last (cdr ,last))))))
    (:method ((k (eql 'append!)) result last short-circuit-tag)
      `(,(intern "APPEND!") (item)
         (setf ,result (append ,result item)
               ,last (last item))
         item))
    (:method ((k (eql 'adjoin!)) result last short-circuit-tag)
      `(,(intern "ADJOIN!") (item &rest adjoin-args)
         (setf ,result (apply #'adjoin item ,result adjoin-args))))
    (:method ((k (eql 'push!)) result last short-circuit-tag)
      `(,(intern "PUSH!") (item)
         (setf ,result (cons item ,result))))
    (:method ((k (eql 'sum!)) result last short-circuit-tag)
      `(,(intern "SUM!") (item)
         (incf ,result item)))
    (:method ((k (eql 'multiply!)) result last short-circuit-tag)
      `(,(intern "MULTIPLY!") (item)
         (setf ,result (* ,result item))))
    (:method ((k (eql 'count!)) result last short-circuit-tag)
      `(,(intern "COUNT!") (item)
         (when item
           (incf ,result))))
    (:method ((k (eql 'minimize!)) result last short-circuit-tag)
      `(,(intern "MINIMIZE!") (item)
         (setf ,result (min (or ,result item) item))))
    (:method ((k (eql 'maximize!)) result last short-circuit-tag)
      `(,(intern "MAXIMIZE!") (item)
         (setf ,result (max (or ,result item) item))))
    (:method ((k (eql 'always!)) result last short-circuit-tag)
      `(,(intern "ALWAYS!") (item)
         (if (not item)
           (progn
             (setf ,result nil)
             (throw ',short-circuit-tag nil))
           item)))
    (:method ((k (eql 'never!)) result last short-circuit-tag)
      `(,(intern "NEVER!") (item)
         (if item
           (progn
             (setf ,result nil)
             (throw ',short-circuit-tag nil))
           t)))
    (:method ((k (eql 'thereis!)) result last short-circuit-tag)
      `(,(intern "THEREIS!") (item)
         (when item
           (setf ,result item)
           (throw ',short-circuit-tag item))))
    (:method ((k (eql 'spr!)) result last short-circuit-tag)
      `(,(intern "SPR!") (&rest args)
         (setf ,result (apply #'spr ,result args)))))

  (defmacro looping (&body body)
    "Run `body` in an environment where the symbols COLLECT!, APPEND!, ADJOIN!,
PUSH!, SUM!, MULTIPLY!, COUNT!, MINIMIZE!, MAXIMIZE!, ALWAYS!, NEVER!, THEREIS!, and SPR! are
bound to functions that can be used to collect / append, sum, multiply, count,
minimize or maximize things respectively.

Mixed usage of COLLECT!/APPEND!/ADJOIN!, SUM!, MULTIPLY!, COUNT!, MINIMIZE! and
MAXIMIZE! is not supported.

Examples:

  (looping
    (dotimes (i 5)
      (if (oddp i)
        (collect! i))))
  =>
  (1 3)

  (looping
    (dotimes (i 5)
      (if (oddp i)
        (sum! i))))
  =>
  4

  (looping
    (dotimes (i 5)
      (count! (oddp i))))
  =>
  2

  (looping
    (dotimes (i 5)
      (sum! i)
      (count! (oddp i))))
  ;; Signals an ERROR: Cannot use COUNT! together with SUM!
  "
    (let1 keywords (remove-duplicates (%extract-reduce-keywords body))
      (%assert-compatible-reduce-keywords keywords)
      (with-gensyms (short-circuit-tag result last)
        (let1 labels (mapcar (lambda (k) (%expand-keyword-into-label k result last short-circuit-tag)) keywords)
          `(let* ((,result ,(%initialize-result keywords))
                  (,last nil))
             (declare (ignorable ,last))
             (labels (,@labels)
               (catch ',short-circuit-tag
                 ,@body
                 ,result)))))))
  

  (defun make-keyword (name)
    "Interns the string designated by `name` in the `keyword` package."
    (intern (string name) :keyword))
  

  (defun mklist (obj)
    "If not already a list, mklist will return a
   new list with its param as element"
    (if (listp obj)
      obj
      (list obj)))
  

  (defun mkstr (&rest args)
    "Receives any number of objects (string, symbol, keyword, char, number), extracts all printed representations, and concatenates them all into one string.

Extracted from _On Lisp_, chapter 4."
    (with-output-to-string (s)
      (dolist (a args) (princ a s))))
  

  (define-modify-macro mulf (&optional (ratio 2)) *
    "A modifying version of multiplication, similar to `incf`.")
  

  (defun ncycle (list)
    "Mutate `list` into a circlular list."
    (nconc list list))
  

  (defun partition-if (f seq)
    "Given a predicate F, partition SEQ into two sublists, the first
of which has elements that satisfy F, the second which do not."
    (let ((yes nil)
          (no nil))
      (map nil
           #'(lambda (x)
               (if (funcall f x)
                   (push x yes)
                   (push x no)))
           seq)
      (values yes no)))
  
  (defun partition-if-not (f seq)
    "Partition SEQ into two sublists, the first whose elements do not
satisfy the predicate F, and the second whose elements do."
    (multiple-value-bind (yes no)
        (partition-if f seq)
      (values no yes)))
  

  (defun plist-keys (plist)
    "Return all the keys of `plist`."
    (loop for k in plist by #'cddr collect k))
  

  (defun plist-values (plist)
    "Return all the values of `plist`."
    (loop for v in (cdr plist) by #'cddr collect v))
  

  (defmacro pmx (form)
    "MACROEXPAND-1 `form` and then PRETTY-PRINT it.

The macro utlimately expands into `form`; this makes it particularly convenient
to wrap an expression with this macro, and see what the expression expands to
without altering the original behavior.
"
    `(progn
       (pprint (macroexpand-1 ',form))
       ,form))
  

  (defun pr (&rest args)
    "Print `args` to screen. Returns the first arg."
    (format t "~{~A~}" args)
    (finish-output)
    (first args))
  

  (defun prn (&rest args)
    "Print `args` to screen, separated by a newline. Returns the first arg."
    (format t "~{~A~^~%~}" args)
    (finish-output)
    (first args))
  

  (defmacro prog1-let ((name result-form) &body body)
    "Like PROG1, except it lets you bind the result of the `result-form` (i.e., the returned
form) to `name` (via LET) for the scope of `body`.

Inspired by ActiveSupport: Object#returning
https://weblog.jamisbuck.org/2006/10/27/mining-activesupport-object-returning.html"
    (prog1-let-expand name result-form body))

  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defun prog1-let-expand (name result-form body)
      `(let1 ,name ,result-form
         ,@body
         ,name)))
  

  (defun prs (&rest args)
    "Print `args` to screen, separated by a space. Returns the first arg."
    (format t "~{~A~^ ~}" args)
    (finish-output)
    (first args))
  

  (defmacro psx (form)
    "PRETTY-PRINT `form`.

The macro utlimately expands into `form`; this makes it particularly convenient
to wrap a reader macro expression with this macro, and see what it expands to
without altering the original behavior.

Examples:

> (psx [oddp _])
; (LAMBDA (&OPTIONAL _) (DECLARE (IGNORABLE _)) (ODDP _))
#<FUNCTION (LAMBDA (&OPTIONAL _)) {B800F9678B}>

> (mapcar (psx [oddp _]) (list 1 2 3))
; (LAMBDA (&OPTIONAL _) (DECLARE (IGNORABLE _)) (ODDP _))
(T NIL T)
"
    `(progn
       (pprint ',form)
       ,form))
  

  (defun random-elt (sequence &key (start 0) end)
    "Returns a random element from `sequence` bounded by `start` and
`end`. Signals an error if the `sequence` is not a proper non-empty
sequence, or if `end` and `start` are not proper bounding index
designators for `sequence`."
    (declare (sequence sequence) (fixnum start) (type (or fixnum null) end))
    (let* ((size (if (listp sequence)
                     (proper-list-length sequence)
                     (length sequence)))
           (end2 (or end size)))
      (cond ((zerop size)
             (error 'type-error
                    :datum sequence
                    :expected-type `(and sequence (not (satisfies emptyp)))))
            ((not (and (<= 0 start) (< start end2) (<= end2 size)))
             (error 'simple-type-error
                    :datum (cons start end)
                    :expected-type `(cons (integer 0 (,end2))
                                          (or null (integer (,start) ,size)))
                    :format-control "~@<~S and ~S are not valid bounding index designators for ~
                                   a sequence of length ~S.~:@>"
                    :format-arguments (list start end size)))
            (t
             (let ((index (+ start (random (- end2 start)))))
               (elt sequence index))))))
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (defmacro recursively (bindings &body body)
    "Execute `body` recursively, like Clojure's `loop`/`recur`.

`bindings` should contain a list of symbols and (optional) starting values.

In `body` the symbol `recur` will be bound to the function for recurring."
    (let ((names (mapcar #'(lambda (b) (if (atom b) b (first b))) bindings))
          (values (mapcar #'(lambda (b) (if (atom b) nil (second b))) bindings)))
      `(labels ((,(intern "RECUR") (,@names)
                 ,@body))
         (,(intern "RECUR") ,@values))))
  )                                        ; eval-when

  (declaim (inline remove/swapped-arguments))
  (defun remove/swapped-arguments (sequence item &rest keyword-arguments)
    (apply #'remove item sequence keyword-arguments))

  (define-modify-macro removef (item &rest remove-keywords)
    remove/swapped-arguments
    "Modify-macro for `remove`. Sets place designated by the first argument to
the result of calling `remove` with `item`, place, and the `keyword-arguments`.")
  

  (defmacro repeat (n &body body)
    "Runs BODY N times."
    `(loop repeat ,n do ,@body))
  

  (defmacro retriable (&body body)
    "Wraps `body` in a RESTART-CASE with a RETRY restart. When invoked, the
restart will re-execute the body forms until they return a non-NIL value.

Returns the first non-NIL value returned by the body forms.

By default, the message reported by the restart case will be \"Retry.\".  This
can be overridden by providing a :report form as the first element of the
body.

Examples:

  ;; Basic usage
  (retriable
    (let ((x (random 10)))
      (when (> x 5)
        x)))

  ;; With custom report message
  (retriable
    (:report \"Try again to get a number greater than 5\")
    (let ((x (random 10)))
      (when (> x 5)
        x)))
"
    (let1 report-args (list "Retry.")
      (if (eq (caar body) :report)
        (setf report-args (cdar body) body (cdr body)))
      `(loop (with-simple-restart (retry ,@report-args)
               (return (progn ,@body))))))
  

  (defun shuffle (sequence &key (start 0) end)
    "Returns a random permutation of `sequence` bounded by `start` and `end`.
Original sequece may be destructively modified, and share storage with
the original one. Signals an error if `sequence` is not a proper
sequence."
    (declare (type fixnum start)
             (type (or fixnum null) end))
    (etypecase sequence
      (list
       (let* ((end (or end (proper-list-length sequence)))
              (n (- end start)))
         (do ((tail (nthcdr start sequence) (cdr tail)))
             ((zerop n))
           (rotatef (car tail) (car (nthcdr (random n) tail)))
           (decf n))))
      (vector
       (let ((end (or end (length sequence))))
         (loop for i from start below end
               do (rotatef (aref sequence i)
                           (aref sequence (+ i (random (- end i))))))))
      (sequence
       (let ((end (or end (length sequence))))
         (loop for i from (- end 1) downto start
               do (rotatef (elt sequence i)
                           (elt sequence (+ i (random (- end i)))))))))
    sequence)
  

  (defun spr (&rest args)
    "Print `args` into a string, and return it."
    (format nil "~{~A~}" args))
  

  (defun sprn (&rest args)
    "Print `args` into a string, separated by a newline, and return it."
    (format nil "~{~A~^~%~}" args))
  

  (defun sprs (&rest args)
    "Print `args` into a string, separated by a space, and return it."
    (format nil "~{~A~^ ~}" args))
  

  (defun string-ends-with-p (suffix s)
    "Returns T if the last few characters of `s` are equal to `suffix`."
    (and (<= (length suffix) (length s))
         (string= suffix s :start2 (- (length s) (length suffix)))))
  

  (defun string-starts-with-p (prefix s)
    "Returns T if the first few characters of `s` are equal to `prefix`."
    (and (<= (length prefix) (length s))
         (string= prefix s :end2 (length prefix))))
  

  (defun subdivide (sequence chunk-size)
    "Split `sequence` into subsequences of size `chunk-size`."
    (check-type sequence sequence)
    (check-type chunk-size (integer 1))
    
    (etypecase sequence
      ;; Since lists have O(N) access time, we iterate through manually,
      ;; collecting each chunk as we pass through it. Using SUBSEQ would
      ;; be O(N^2).
      (list (loop :while sequence
                  :collect
                  (loop :repeat chunk-size
                        :while sequence
                        :collect (pop sequence))))
      
      ;; For other sequences like strings or arrays, we can simply chunk
      ;; by repeated SUBSEQs.
      (sequence (loop :with len := (length sequence)
                      :for i :below len :by chunk-size
                      :collect (subseq sequence i (min len (+ chunk-size i)))))))
  

  (defun subseq- (seq &optional (start nil) (end nil))
    "Like SUBSEQ, except it supports negative indices."
    (if (not start)
      (setf start 0)
      (if (< start 0)
        (setf start (+ (length seq) start))))
    (if (not end)
      (setf end (length seq))
      (if (< end 0)
        (setf end (+ (length seq) end))))
    (subseq seq start end))
  

  (defun symb (&rest args)
    "Receives any number of objects, concatenates all into one string with `#'mkstr` and converts them to symbol.

Extracted from _On Lisp_, chapter 4.

See also: `symbolicate`"
    (values (intern (apply #'mkstr args))))
  

  (defun take (n sequence)
    "Take the first `n` elements from `sequence`."
    (subseq sequence 0 (min (length sequence) n)))
  

  (defmacro undefclass (class direct-superclasses direct-slots &rest options)
    "Removes the association between `class` and its class object.

A mere wrapper around (setf (find-class class) nil), except it has the same
signature of DEFCLASS; this makes it particularly easy to undefine a class by
simply changing DEFCLASS into UNDEFCLASS"
    (declare (ignore direct-superclasses direct-slots options))
    `(setf (find-class ',class) nil))
  

  (defmacro undefconstant (name value &optional (doc nil))
    "Makes the symbol be unbound, regardless of whether it was previously bound.

Similar to MAKUNBOUND, except it has the same signature of DEFCONSTANT; this
makes it particularly easy to make a symbol unbound by simply changing
DEFCONSTANT into UNDEFVAR"
    (declare (ignore value doc))
    `(makunbound ',name))
  

  (defmacro undefmacro (name lambda-list &body body)
    "Removes the function or macro definition, if any, of `name` in the global
environment.

Similar to FMAKUNBOUND, except it has the same signature of DEFUN; this makes
it particularly easy to undefine a function or a macro by simply changing DEFUN
into UNDEFUN and DEFMACRO into UNDEFMACRO"
    (declare (ignore lambda-list body))
    `(fmakunbound ',name))
  

  ;; https://groups.google.com/g/comp.lang.lisp/c/W6OrfjLhPJ8/m/txPfD-pPqPMJ
  (defmacro undefmethod (name &rest args)
    "Removes a method from a generic-function `name`.

This macro's signature matches DEFMETHOD's one, and `args` will be used to
extract the method qualifiers and specializers necessary to find the right
method to remove; this makes it particularly easy to undefine a method by
simply changing DEFMETHOD into UNDEFMETHOD"
    (flet ((parse-undefmethod-args (args)
             (let (p q method-qualifiers specializers)
               (loop (cond ((atom (setq p (car args))) (push p method-qualifiers))
                           (t (return))) ; now P is the specialized-lambda-list
                     (setq args (cdr args)))
               (loop (when (null p) (return))
                     (cond ((symbolp (setq q (car p)))
                            (case q
                              ((&aux &key &optional &rest &allow-other-keys) (return))
                              (t (push T specializers)))) ; handle eql specializers:
                           ((consp (cadr q)) (push (cadr q) specializers))
                           (t (push (find-class (cadr q)) specializers)))
                     (setq p (cdr p)))
               (values (nreverse method-qualifiers) (nreverse specializers)))))
      `(let ((fdefn (fdefinition ',name)))
         (multiple-value-bind (qualifiers specializers)
             (parse-undefmethod-args ',args)
           (let ((meth (find-method fdefn qualifiers specializers)))
             (when meth (remove-method fdefn meth)))))))
  

  (defmacro undefpackage (name &rest options)
    "Deletes `package` from all system data structures.

Similar to DELETE-PACKAGE, except it has the same signature of DEFPACKAGE; this
makes it particularly easy to delete a package by simply changing DEFPACKAGE
into UNDEFPACKAGE"
    (declare (ignore options))
    `(delete-package ',name))
  

  (defmacro undefparameter (var val &optional (doc nil))
    "Makes the symbol be unbound, regardless of whether it was previously bound.

Similar to MAKUNBOUND, except it has the same signature of DEFPARAMETER; this
makes it particularly easy to make a symbol unbound by simply changing
DEFPARAMETER into UNDEFVAR"
    (declare (ignore val doc))
    `(makunbound ',var))
  

  (defmacro undefun (name lambda-list &body body)
    "Removes the function or macro definition, if any, of `name` in the global
environment.

Similar to FMAKUNBOUND, except it has the same signature of DEFUN; this makes
it particularly easy to undefine a function or a macro by simply changing DEFUN
into UNDEFUN and DEFMACRO into UNDEFMACRO"
    (declare (ignore lambda-list body))
    `(fmakunbound ',name))
  

  (defmacro undefvar (var &optional (val nil) (doc nil))
    "Makes the symbol be unbound, regardless of whether it was previously bound.

Similar to MAKUNBOUND, except it has the same signature of DEFVAR; this makes
it particularly easy to make a symbol unbound by simply changing DEFVAR into
UNDEFVAR"
    (declare (ignore val doc))
    `(makunbound ',var))
  

  (defmacro until (expression &body body)
    "Executes `body` until `expression` is true."
    `(do ()
         (,expression)
       ,@body))
  

  (defun void (&rest args)
    "Do absolutely nothing, and return absolutely nothing."
    (declare (ignore args))
    (values))
  

  (defmacro when-let (bindings &body forms)
    "Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

All initial-forms are executed sequentially in the specified order. Then all
the variables are bound to the corresponding values.

If all variables were bound to true values, then FORMS are executed as an
implicit PROGN."
    (let* ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                             (list bindings)
                             bindings))
           (variables (mapcar #'car binding-list)))
      `(let ,binding-list
         (when (and ,@variables)
           ,@forms))))

  (defmacro when-let* (bindings &body forms)
    "Creates new variable bindings, and conditionally executes FORMS.

BINDINGS must be either single binding of the form:

 (variable initial-form)

or a list of bindings of the form:

 ((variable-1 initial-form-1)
  (variable-2 initial-form-2)
  ...
  (variable-n initial-form-n))

Each initial-form is executed in turn, and the variable bound to the
corresponding value. Initial-form expressions can refer to variables
previously bound by the WHEN-LET*.

Execution of WHEN-LET* stops immediately if any initial-form evaluates to NIL.
If all initial-forms evaluate to true, then FORMS are executed as an implicit
PROGN."
    (let ((binding-list (if (and (consp bindings) (symbolp (car bindings)))
                            (list bindings)
                            bindings)))
      (labels ((bind (bindings forms)
                 (if bindings
                     `((let (,(car bindings))
                         (when ,(caar bindings)
                           ,@(bind (cdr bindings) forms))))
                     forms)))
        `(let (,(car binding-list))
           (when ,(caar binding-list)
             ,@(bind (cdr binding-list) forms))))))
  

  (defmacro when-not (test &body body)
    "Like WHEN, except TEST gets wrapped inside NOT."
    `(when (not ,test) ,@body))
  

  (defmacro while (expression &body body)
    "Executes `body` while `expression` is true."
    `(loop while ,expression do
       ,@body))
  
  (abbr while-not until)

  (defmacro xor (&rest datums)
    "Evaluates its arguments one at a time, from left to right. If more than one
argument evaluates to a true value no further `datums` are evaluated, and `nil` is
returned as both primary and secondary value. If exactly one argument
evaluates to true, its value is returned as the primary value after all the
arguments have been evaluated, and `t` is returned as the secondary value. If no
arguments evaluate to true `nil` is retuned as primary, and `t` as secondary
value."
    (with-gensyms (xor tmp true)
      `(let (,tmp ,true)
         (block ,xor
           ,@(mapcar (lambda (datum)
                       `(if (setf ,tmp ,datum)
                            (if ,true
                                (return-from ,xor (values nil nil))
                                (setf ,true ,tmp))))
                     datums)
           (return-from ,xor (values ,true t))))))
  

  (define-modify-macro zapf (function)
    (lambda (value function)
      (funcall function value))
    "Generic place modify macro, like PUSH or INCF, which sets `place`
equal to (funcall function place).

Here is how INCF and PUSH can be implemented using ZAPF:

(incf x) ≡ (zapf x #'1)
(incf x 2) ≡ (zapf x (lambda (x) (+ x 2)))
(push \"foo\" x) ≡ (zapf x (lambda (x) (cons \"foo\" 2)))

Additional reading:
- https://stevelosh.com/blog/2016/08/playing-with-syntax/
- https://malisper.me/zap/")
  

  (defmacro ~> (x &rest forms)
    "Threads the expr through the forms, like Clojure's `->`.

While threading, for each element of `forms`:

- if a SYMBOL, it's converted into a function call with the accumulated value
as it's first argument
- if a function call already, the accumulated value is **prepended** to the
list of args unless it contains the placeholder '~ (in which case '~ is
replaced with the accumulated value)

Examples:

(~> 'Hello
  (list 'World))
=>
(HELLO WORLD)

(~> 'Hello
  (list 'World ~))
=>
(WORLD HELLO)

(~> 'Hello
  (list 'World ~)
  reverse)
=>
(HELLO WORLD)
  "
    (labels ((replace-or-prepend (old form new)
               (if (contains? old form)
                 (subst new old form)
                 (list* (car form) new (cdr form))))
             (contains? (target form)
               (recursively ((form form))
                 (if (atom form)
                   (eq form target)
                   (or (recur (car form))
                       (recur (cdr form)))))))
      (let ((placeholder (intern "~")))
        (with-gensyms (result)
          `(let* ((,result ,x)
                  ,@(mapcar (lambda (form)
                              (if (atom form)
                                `(,result (,form ,result))
                                `(,result ,(replace-or-prepend placeholder
                                                               form
                                                               result))))
                            forms))
             ,result)))))
  
(eval-when (:compile-toplevel :load-toplevel :execute)
  (export '(@ aand aif alist alist-keys alist-values appendf aprog1 assoc-value
            rassoc-value awhen bnd* bnd1 copy-array copy-hash-table dbg dbgl
            defaccessor accesses digits divf doalist dohash dohashk dohashv
            dolists dorange dorangei doseq doseqs dosublists enumerate flatten
            fn hash-table-alist hash-table-key-exists-p hash-table-keys
            hash-table-values if-let if-not iota keep-if keep-if-not last-elt
            let1 looping make-keyword mklist mkstr mulf ncycle partition-if
            partition-if-not plist-keys plist-values pmx pr prn prog1-let prs
            psx random-elt recursively removef repeat retriable shuffle spr
            sprn sprs string-ends-with-p string-starts-with-p subdivide subseq-
            symb take undefclass undefconstant undefmacro undefmethod
            undefpackage undefparameter undefun undefvar until value-at void
            when-let when-let* when-not while while-not with-gensyms
            with-unique-names xor zapf ~>)))

;;;; END OF quickutils.lisp ;;;;
